在基础红石原理中，我们将方块的亚稳态称为BUD态，能够更新处于BUD态的方块的信号称为方块更新信号，能够检测方块更新信号的装置称为BUD。但事实上，其他的一些装置如TEUD，观察者等似乎可以对其他信号做出相应，这意味着游戏存在更多类型的方块更新信号。对更多更新信号的研究对启动更新理论进行了拓展。

TEUD是一种BUD，但不同于常规BUD，它检测的内容不止是方块更新，本质上与BUD“检测方块更新”这一最初的概念不相符合，因此BUD这一词的概念应当有所扩大。现在我们认为，BUD是一种直接或间接检测方块变化的装置，检测方块更新信号的BUD称为常规BUD，其余称为非常规BUD。在一些资料中，常规BUD被直接简称为BUD，《基础红石原理》也是这样做的。而现在BUD一词已经拥有较多含义，为使读者不至混淆而产生歧义，本书之后不再做这种简称。TEUD就是最典型、最常见、最具有代表性的非常规BUD。

基础的延迟理论旨在解释红石元器件和活塞的运行规律，但游戏中的红石元件显然不仅限于此。漏斗和观察者也是非常重要的红石元件，延迟理论的拓展将主要研究这两个元件。

<!-- TOC depthFrom:1 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 -->

- [第一节 TEUD](#第一节-teud)
	- [TEUD的简介](#teud的简介)
	- [TEUD的制作](#teud的制作)
	- [TEUD的功能](#teud的功能)
- [第二节 观察者](#第二节-观察者)
	- [观察者的输出特性](#观察者的输出特性)
	- [观察者的输入特性](#观察者的输入特性)
- [第三节 方块更新信号](#第三节-方块更新信号)
	- [方块更新信号与方块变化的辩证关系](#方块更新信号与方块变化的辩证关系)
	- [NC更新与PP更新（还没写）](#nc更新与pp更新还没写)
	- [更新抑制（还没写）](#更新抑制还没写)
- [第四节 漏斗理论](#第四节-漏斗理论)
	- [漏斗概述](#漏斗概述)
	- [即时更新理论对漏斗的修正](#即时更新理论对漏斗的修正)
	- [漏斗理论](#漏斗理论)
- [第五节 0t脉冲](#第五节-0t脉冲)
	- [0t脉冲的细化](#0t脉冲的细化)
	- [活塞更新深度](#活塞更新深度)
	- [超频时钟（还没写）](#超频时钟还没写)

<!-- /TOC -->

# 第一节 TEUD
## TEUD的简介

TEUD（Tile Entity Data Update Detector），又称DUD（Data Update Detector）或CUD（Comparator Update Detector），即比较器更新检测器，是一种BUD的拓展衍生物，其检测的不只是方块更新信号。

游戏需要检测方块是否处于正常的状态，因而有了方块更新信号，检测方块更新信号的检测器就是方块更新检测器。同样，比较器具有满箱检测的功能，其可以检测容器、炼药锅、物品展示框、末地传送门框架及探测铁轨上的矿车等诸多项目，可以预想到这些项目的检测依赖于另一种更新信号，也就是比较器更新信号，检测比较器更新信号的检测器就是比较器更新检测器了。TEUD的核心元件是比较器，因此TEUD比常规BUD有更广的检测范围。

最早已知且仍然稳定可用的一种TEUD实现是由NiceMarkMC给出的，时间不晚于2013年5月初。在此之前的若干研究与讨论都为TEUD的成型做出了铺垫。

比较器更新信号具有和方块更新信号不同的性质。最大的不同就是方块更新信号一般的更新范围是方块的毗邻，即使红石元件有较大的更新范围，这个更新范围也是由产生更新的方块主导的；比较器更新信号则允许更新信号沿四周的实体方块传递一格，如果不存在实体方块，比较器更新信号也就不会产生。这显然是因为比较器可以通过实体方块进行满箱检测。

## TEUD的制作

TEUD的核心是陷入BUD态的比较器，而TEUD必须实现自复位功能，这是TEUD的根本原理。让比较器陷入BUD态的方式多种多样，但大多数方案都使用了比较器检测戴尔功能。其中，箱基TEUD的制作最为简便。

箱子可以被红石比较器直接检测或隔着一个实体方块被红石比较器检测，当箱子内有物品且箱子没有被实体方块压住时，比较器才会输出信号。如果在内含物品的箱子上方拿实体方块压住箱子，比较器理论上讲应该会熄灭，但是由于这一行为往往无法更新到比较器，比较器就会陷入BUD态。这样一来，比较器就可以检测比较器更新信号了。用活塞控制实体方块压箱子可以将这一原理自动化。下图就是一个箱基TEUD。当更新比较器时，比较器熄灭，活塞收回，收回结束更新到比较器，比较器点亮，活塞伸出，压住箱子，TEUD复位。

![](assets/方块更新与延迟理论的拓展-880a3460.png)

若使得箱基TEUD的活塞不会更新到比较器，便可以制作出双稳态箱基TEUD，可以使用大箱子做到这一点。

![](assets/方块更新与延迟理论的拓展-2e508404.png)

物品展示框可以被比较器检测。物品展示框作为一个实体可以与其他碰撞不完整的方块共处一个方块内，但是此时比较器无法检测物品展示框，因此可以做出TEUD。 值得一提的是，这是一个双稳态TEUD。

![](assets/方块更新与延迟理论的拓展-f85f8547.png)

炼药锅可以用于制作TEUD，其可以被比较器检测，但重点在于其可以被活塞移动，这就给出了一种极佳的自复位方法。

![](assets/方块更新与延迟理论的拓展-a2d9feec.png)

比较器可以检测探测铁轨上的矿车，而粘性活塞可以移动探测铁轨。这一过程主要是探测铁轨在产生比较器更新信号。

![](assets/方块更新与延迟理论的拓展-f1de4f0a.png)

箱基TEUD也可以不使用实体方块而使用猫，猫会主动坐在箱子、床及燃烧的熔炉上，当猫坐在箱子上时，箱子无法被打开，比较器也无法进行检测。

![](assets/方块更新与延迟理论的拓展-f8955afc.png)

利用红石指向BUD可以使一切输出元件陷入BUD态，比较器也不例外。

![](assets/方块更新与延迟理论的拓展-c3f44a3d.png)

## TEUD的功能

在TEUD中，比较器陷入了BUD态，这意味着TEUD也能检测常规BUD所能检测的事项，为将比较器更新信号从方块更新信号中分离出来，我们可以利用比较器更新信号特殊的传递方式，隔着一个实体方块用特定事项更新比较器，这一过程称为TEUD的分离，隔着一个实体方块使TEUD动作的过程称为TEUD的响应。但红石元件往往具有较大的更新范围，即使隔着一个实体方块有时也无法成功分离方块更新信号和比较器更新信号，这种情况称为TEUD的分离失效。

除TEUD分离失效外，TEUD可以分离出许多比较器更新信号，从这一点来说，TEUD可以使纯红石系统的认知范围扩大。BUD现象的出现证实了游戏内存在方块更新信号，而TEUD则证实了游戏内存在着另一种更新信号——比较器更新信号。如果没有BUD和TEUD，这些更新信号像幽灵一样在游戏内运行而无法为人感知。因此是某些方块的变化，产生了特定的更新信号，这些更新信号由BUD或TEUD检测，才间接得知方块变化的发生，这是BUD和TEUD扩展纯红石系统的认知范围的原理。

TEUD主要检测容器及类容器的“内容物”发生变化。TEUD会响应箱子、熔炉、酿造台等容器的内容物信息变化。放置或破坏容器、直接取走或放入物品、通过漏斗取走或放入物品、投掷器或发射器投出物品、用其他物品替代已有物品甚至是在容器内左键或右键均会使TEUD响应。投掷器的空投、按住Shift左键或右键容器内部、打开和关闭容器、在容器内拖动左键或右键但不放开不会造成内容物的变化，TEUD不会响应。工作台、末影箱、花盆和音符盒不是容器，TEUD不会响应。

“类容器”是指类似容器的方块或实体，其没有类似箱子的GUI界面，但仍可以存储比较器可以检测的信息。其中如炼药锅、末地传送门框架等方块利用方块数据值存储信息，唱片机等方块使用方块实体值存储信息，物品展示框使用实体数据存储信息。探测铁轨可以“容纳”矿车，可以把探测铁轨也视为类容器，本小节会在最后对其进行研究。类容器方块会在被放置时产生比较器更新信号，破坏时不会产生；物品展示框在放置时不会产生比较器更新信号，破坏时会产生。

以下展示了常见的TEUD响应项：

- 将末影之眼放入末地传送门框架
- 将唱片插入唱片机或从中取出
- 炼药锅的水位变化
- 在讲台上放置或取下书籍、翻书

不过由于比较器本身就可以检测类容器的“内容物”变化，TEUD在这些项目的检测上并没有带来新的拓展。

TEUD和探测铁轨搭配时，会产生令人吃惊的效果：TEUD不再检测容器的内容物，转而成为一个实体检测器——当探测铁轨所在方块与某一实体碰撞箱有交集时，TEUD便会响应。因此，即使是浮空的实体也会触发TEUD。物品展示框、闪电不会使TEUD响应。如下图右侧的箭会触发TEUD，而左侧不会。

![](assets/方块更新与延迟理论的拓展-f2c2be17.png)

如下是一个角度刁钻的例子：

![](assets/方块更新与延迟理论的拓展-eb1ef670.png)。

当实体与探测铁轨所在的方块接触时，实体会促使探测铁轨发出比较器更新信号，除箭外，这个信号是周期性的，但不同实体的周期不同：所有矿车的周期是20gt;物品为6gt；生物、钓鱼竿吊钩等大多数实体的周期为4gt；玩家的周期小于4gt，可以认为小于TEUD的自复位时间；箭只会在射到其上时产生1次比较器更新信号。~~（在这一方面似乎需要更多的研究。）~~

![](assets/方块更新与延迟理论的拓展-1e2721d3.png)

# 第二节 观察者

观察者拥有一个检测端和一个输出端，其中检测端可以检测检测面方块的方块变化。当观察者认可该方块变化时，以15强度强充能其指向，给予毗邻及指向的毗邻方块更新，脉冲长度为2gt。另外，放置观察者不会引起检测端输入。

虽然观察者的确可以对红石信号做出响应，但该响应是由于观察者检测到了方块变化，因而不认为观察者是输出元件，观察者是一个输入元件。

## 观察者的输出特性

观察者是一个NTE元件，优先级为0，有2gt的启动延迟，换句话说，其会在检测端输入后的第二个NTE事件开始输出信号，信号持续2gt，并在第四个NTE事件停止输出信号。在检测端输入到停止输出这段时间内，观察者无视一切方块变化。观察者开始输出信号时，先给予毗邻更新信号，随后输出15强度红石信号；结束输出信号时，先结束红石信号的输出，随后给予毗邻更新信号。*（有待考察）*

观察者的一个重要特性是观察者可以被活塞推动，下面介绍观察者被活塞推动时的输出特性。

- **当观察者处于未触发态时（包括启动延迟），若观察者被活塞推动，其会将推动结束的BE事件或TE事件作为观察者的检测端输入。**
- **当观察者处于触发态时，若观察者被活塞推动，其在结束推动后保持无信号输出。**

在1.11引入观察者后，狼顾之鬼怪才（Joker_小狼）在《观察者性质总结》中率先研究了观察者的诸多性质，如下的两道例题便引自该文献。

*例 2 计算上下路延迟，判断时序比较器的输出情况。*

![](https://github.com/Xiaoyuan-xyz/The-Principle-of-Redstone-Circuits/raw/master/Illustration/粘液块与观察者技术/1-3-1.png)

*解：粘性活塞启动延迟1gt，观察者启动延迟2gt，因而在观察者未触发时，粘性活塞开始推动观察者。推动结束后，观察者于TE事件开始进入启动延迟，启动延迟2gt，故上路延迟5gt。下路延迟4gt，从而时序比较器激活锁定。
由于时序比较器在延迟相等时处于未激活锁定，这就证明了上路延迟一定大于4gt，从而说明观察者在被活塞推动结束后，启动延迟仍为2gt。*

![](https://github.com/Xiaoyuan-xyz/The-Principle-of-Redstone-Circuits/raw/master/Illustration/粘液块与观察者技术/1-3-2.png)

*例 3 拉杆拉下后，TNT能否爆炸？为什么？*

![](https://github.com/Xiaoyuan-xyz/The-Principle-of-Redstone-Circuits/raw/master/Illustration/粘液块与观察者技术/1-3-3.png)

*解： 中继器延迟2gt，活塞无启动延迟，故活塞将在观察者触发的第一个BE事件推动观察者，推出结束后无信号输出，TNT不会爆炸。*

![](https://github.com/Xiaoyuan-xyz/The-Principle-of-Redstone-Circuits/raw/master/Illustration/粘液块与观察者技术/1-3-4.png)

下面介绍“脸对脸”的观察者时钟，这种时钟构造简单，在观察者被引入后得到了许多玩家的喜爱。

![](https://github.com/Xiaoyuan-xyz/The-Principle-of-Redstone-Circuits/raw/master/Illustration/粘液块与观察者技术/1-3-5.png)

两个观察者“脸对脸”，互相检测对方的变化，两个输出端给出的是互补的，周期为4gt，占空比为50%的高频时钟信号。一般配合粘性活塞来关闭或开启这种时钟。

下面应用红石更新延迟理论对该时钟进行分析。

拉杆拉下，粘性活塞有1gt启动延迟，随后粘性活塞于BE事件伸出，左边的观察者以此为检测端输入，启动延迟为2gt。其于拉杆拉下3gt，也就是第三个NTE事件开始输出信号。粘性活塞总延迟3gt，其于第三个NTE事件后的TE事件将右边的观察者推出到位，观察者以此作为检测端输入。5gt后，左边观察者结束输出，右面观察者开始输出，由于左边观察者于3gt NTE事件进入NTE列表，右边观察者于3gt TE事件进入NTE列表，左边观察者先于右边观察者更新，因此在5gt时，左边观察者先结束输出，右边观察者后开始输出。因此右边观察者由非触发态转变为触发态的方块变化可以被左边的观察者检测到，左边观察者重新进入启动延迟。两个观察者以此往复，可以得出周期为4gt，占空比为50%的结论。

![1-3-6 （草稿）](https://github.com/Xiaoyuan-xyz/The-Principle-of-Redstone-Circuits/raw/master/Illustration/粘液块与观察者技术/paint1.png)

一个有意思的现象是，如果第二个观察者不是由活塞推入的，而是由玩家放置的，我们可以明显觉察到时钟变慢了，而且可以观察到两个观察者同时熄灭的瞬间，此时时钟周期不再是4gt，而是更慢的6gt。

![1-3-7](https://github.com/Xiaoyuan-xyz/The-Principle-of-Redstone-Circuits/raw/master/Illustration/粘液块与观察者技术/1-3-7.png)

下面对玩家放置的观察者时钟进行分析。

玩家放置第二个观察者后，其本身不会响应，但第一个观察者会以此为检测端输入，2gt后，更新第二个观察者，同时自身开始输出信号。4gt后，第二个观察者开始输出信号，但第一个观察者结束输出晚于第二个观察者，故第一个观察者不会响应此次方块变化，而第二个观察者此时正处于激活态，不响应第一个观察者结束输出带来的方块变化。第一个观察者会在6gt后检测到第二个观察者结束输出的方块变化，并以此往复。

![1-3-8（草稿）](https://github.com/Xiaoyuan-xyz/The-Principle-of-Redstone-Circuits/raw/master/Illustration/粘液块与观察者技术/paint2.png)

## 观察者的输入特性
观察者的输入特性指的是观察者会对怎样的方块变化产生响应，亦即观察者可以检测到哪些方块变化。在1.15版本(1.13+)中观察者的输入特性较为简单，可以被总结为：

> **观察者检测一切方块名称和状态的变化。**

在1.13的扁平化进程后，方块的英文ID被用来区分不同的方块，不同的方块一定有着不同的英文ID；方块的数据值用于区分同一方块的不同状态，如不同朝向的火把，或不同水量的炼药锅；方块的实体值用于记录方块的附加属性，如告示牌的文字，或箱子里的物品。那么，观察者检测是的英文ID的变化及方块数据值的变化。一切ID的变化或数据值的变化都能引起观察者的响应。打开F3界面可以轻易看出这一点。

从观察者的引入到特性逐渐稳定，期间经过了若干个版本，但最后的观察者所保留的特性是较为简明的，我们可以简单地理解为：

> **观察者并不检测方块更新信号，观察者响应方块变化。**

即使如此，我们仍有必要对一些特殊的示例具体分析。

由于观察者检测的是方块变化，而非方块更新，而活塞推动方块会在开始推动时就将趋势位设置为36号方块，观察者就可以捕捉到这一变化。因此右侧的两个红石灯会同时亮起，而左侧的两个红石灯会有3gt的延迟差，这3gt相差在了前一个活塞的2gt推出延迟和后一个活塞的1gt启动延迟。

![1-3-9](https://github.com/Xiaoyuan-xyz/The-Principle-of-Redstone-Circuits/raw/master/Illustration/粘液块与观察者技术/1-3-9.png)

投掷器和发射器以及漏斗，在F3界面的triggered或enabled数据值往往不能反映其的真实状态，需要玩家查看其内容其才能被更新到正确的值，暂不明确这是否为一个bug。但观察者可以正常检测投掷器、发射器和漏斗工作状态。特别是投掷器的空投和漏斗的锁定解锁，这是非观察者所不能检测的。

![1-3-10](https://github.com/Xiaoyuan-xyz/The-Principle-of-Redstone-Circuits/raw/master/Illustration/粘液块与观察者技术/1-3-10.png)

栅栏，红石线，拌线等方块是依据自身的方块数据值来区分自己的连接情况的，因此观察者可以检测这些方块的连接状态是否发生改变，例如下图1的装置就可以区分一个方块能否与栅栏相连接，而下图2的示例中，无论破坏哪一个红石线，观察者都会响应。
![1-3-11](https://github.com/Xiaoyuan-xyz/The-Principle-of-Redstone-Circuits/raw/master/Illustration/粘液块与观察者技术/1-3-11.png)

![1-3-12](https://github.com/Xiaoyuan-xyz/The-Principle-of-Redstone-Circuits/raw/master/Illustration/粘液块与观察者技术/1-3-12.png)

酿造台的数据值仅用于说明酿造台当前的瓶子数量及位置，因此观察者也只能检测这些。

![1-3-13](https://github.com/Xiaoyuan-xyz/The-Principle-of-Redstone-Circuits/raw/master/Illustration/粘液块与观察者技术/1-3-13.png)

在1.13的扁平化进程后，树叶使用1-7的distance数据值用于标明其与最近原木的距离，这个值最大是7。同理，观察者可以检测到树叶distance数据值的变化，这一特性最早由2No2Name于2018年7月23日发现。关于观察者检测树叶，下一节会做更多详细的描述。

![1-3-14](https://github.com/Xiaoyuan-xyz/The-Principle-of-Redstone-Circuits/raw/master/Illustration/粘液块与观察者技术/1-3-14.png)

脚手架于1.14被加入游戏，值得注意的是其拥有的两个数据值——bottom数据值和distance数据值。bottom数据值用于指示脚手架下方的方块是否能够支撑脚手架，0-7的distance数据值用于标明其累计横向拓展的距离，最大可以拓展6格，这个数据值与树叶的distance数据值具有相似的性质，但其只计量横向距离。观察者自然可以响应这两个数据值的变化。

![](https://github.com/Xiaoyuan-xyz/The-Principle-of-Redstone-Circuits/raw/master/Illustration/粘液块与观察者技术/粘液块及观察者技术-ee5f1bdd.png)

可含水方块拥有waterlogged数据值，水流拥有level数据值，观察者可以检测这些方块或流体的数据值变化。

![1-3-15](https://github.com/Xiaoyuan-xyz/The-Principle-of-Redstone-Circuits/raw/master/Illustration/粘液块与观察者技术/1-3-15.png)

# 第三节 方块更新信号

## 方块更新信号与方块变化的辩证关系

面对常规BUD，我们可以说某些方块变化引起了方块更新信号，从而更新常规BUD，使其响应。也可以说常规BUD检测某些相对位置上特定的方块变化，这就是方块变化与更新信号的辩证关系。实践证明这种关系在研究观察者的检测时提供了很好的思维动力。换句话讲，我们不再关心方块更新的底层实现，而只把BUD作为拓展纯红石体系认知能力的一种手段。

事实上，这种思想在输出元件的激活上也有体现，我们分别使用两种角度对待元件的激活：红石灯等较为简单地元件使用的是“红石线激活红石灯则亮起”的思路，而活塞等实则是“活塞激活位上有信号则推出”的思路。我们把这一点类比到方块更新理论中。从更新信号的角度看，是方块变化引起更新信号，不同的更新信号更新到不同类型的BUD，从而使其响应。从方块变化的角度，是不同类型的BUD检测特定的方块变化项，在属于这个特性方块变化项集合的某一个方块变化项发生时，该类型BUD响应。

那么，什么样的方块变化能够引起一类BUD的相应呢？很不幸，这两者之间没有绝对的关系。

举例来说，红石元器件所产生方块更新信号范围都较大因而产生BUD覆盖，例如红石线的强度变化，TEUD和常规BUD会有相同的响应。漏斗传输物品并不会产生方块更新，因此能被TEUD分离，而且漏斗内部的物品变更，本身就是一个方块变化，因此可以被观察者检测。投掷器的撤销激活不会产生任何方块更新或附加值更新信号，其内部的物品甚至没有变化，但是我们曾在投掷器的激活判定一节中提到：投掷器被激活后会变为激活的投掷器，撤销激活会变回。这显然是一个变化，可以用观察者检测。而中继器充能方块激活红石线的过程，实质上是中继器借助了实体方块而激活红石线，我们只把这种充能看做玩家对电路的分析方式，实体方块本身并没有什么变化，因此不会被观察者响应。

通常来说，常规BUD、TEUD、以及观察者的检测范围都是不一样的，需要根据不同的需求采取不同的检测方式。而观察者也带来了超出方块更新体系的一面，观察者作为可移动的信号方式，并且有着奇特的激活方式。这样说来，观察者是1.11加入的新方块，其具有的特殊价值，以及新的利用方式还有待玩家积极开发，观察者有着非常大的应用前景。

## NC更新与PP更新（还没写）

在1.13后，游戏使用NeighborChanged（邻位更新）和PostPlacement（放置后更新）两种更新信号。

## 更新抑制（还没写）

# 第四节 漏斗理论

## 漏斗概述

漏斗是于1.5版本中加入的红石输出元件，其具有5格的存储空间。漏斗的主要功能被称为漏斗的输出特性，简述如下：

- 将其上1×1×1范围内的物品实体吸入自己的存储空间。
- 漏斗可以从上方的容器中抽取物品，如果漏斗上方有容器，漏斗不再尝试吸入物品实体。
- 漏斗可以将存储空间中的物品，传输至自己指向的容器中。漏斗的指向只能是下方或四周，因此只用漏斗是不可能将物品向上传递的。

当漏斗被激活时，称漏斗被“锁”住，此时失去如上的功能。漏斗被激活时可以发生变化，因此是一个输出元件。

能与漏斗进行互动的容器或类容器有包括：

- 箱子和陷阱箱，但不包括末影箱，漏斗能简单地从箱子中取出，或放入物品。
- 发射器、投掷器、末影盒。
- 箱子矿车、漏斗矿车。（尽管它们是实体而非方块）
- 熔炉，在熔炉上方并指向熔炉的漏斗会将物品输入到待烧炼的物品格，在侧面并指向熔炉的漏斗会将物品输入到燃料的物品格，在熔炉下方的漏斗会将物品从成品的物品格中取出，不过，当使用岩浆桶作为燃料时，漏斗也可以将空桶取出。
- 酿造台，漏斗可以向酿造台中输入水瓶、烈焰粉及酿造原料，同时也会将药水取出，不过值得注意的是只要输出栏中有药水，无论酿造是否完成，漏斗都会直接取出。
- 其他漏斗，漏斗也可以将物品输入其他漏斗，或是从其他漏斗中将物品取出，两个漏斗可以同时进行自己的工作，相互独立。

漏斗具有很多功能，而这些功能在实现时需要运算，也就会带来卡顿。激活漏斗可以禁用漏斗的一切功能，此时卡顿最小 ~~（有待考据）~~。如果某些漏斗仅用作物品传输而非吸入物品，或不希望杂物导入物品中，可以在漏斗上放置容器，此时漏斗不再尝试吸入物品。但多放置的容器也会带来一定的卡顿，因为此时不仅漏斗要尝试从容器中取出物品，熔炉等方块还会尝试是否开始燃烧，选择合适的容器是有必要的。漏斗上的容器物品格数越少，漏斗取出物品时检测越少，卡顿也就越小，因此投掷器优于小箱子，后者又优于大箱子。熔炉、炼药台等容器物品栏较为特殊，需要特殊处理，最终效果与投掷器类似。堆肥桶没有物品栏，漏斗直接检测堆肥桶的方块数据值，带来的卡顿是极小的，这也是目前最合适的放置在漏斗上用于减小卡顿的类容器。

漏斗的延迟是8gt，这是一个值得记忆的数据，这一延迟限制了物品在漏斗内的传输速率，换算成常用单位，也就是2.5物品每秒，或150物品每分钟，或9000物品每小时。

漏斗是一个方块实体，统一在Tile Entity事件更新，同一游戏刻内的更新顺序取决于加载顺序，如玩家先放置的漏斗总先更新。必须注意的是区块重载会破坏已有的加载顺序，重载的顺序具有随机性。

## 即时更新理论对漏斗的修正

Sancarn和Selulance尝试将漏斗纳入即时更新理论的范畴。

必须研究漏斗对于不同同步性的下降沿信号，将物品开始漏下需要多久的延迟。

![](assets/方块更新与延迟理论的拓展-36edd094.png)

事实证明，对大部分信号，漏斗是一个同步元件，延迟为1pt。这意味着漏斗和活塞类似，有着1pt的固定延迟。

接下来，必须研究比较器从漏斗中读取有信号时，漏斗作为输入元件的同步性。

![](assets/方块更新与延迟理论的拓展-7c0a0eb0.png)

事实证明，漏斗也是一个同步性输入元件，其会减少比较器的1pt延迟。

然而漏斗并非是严格意义上的同步元件。换句话说，同步信号会减少非同步元件的1pt延迟，但不会对同步信号产生影响，漏斗却会被优先的几种同步信号减少1pt延迟，且这些同步信号总与实体有关，如掉落沙。

![](assets/方块更新与延迟理论的拓展-c7777872.png)

可以预料到，掉落沙这种同步性输入方式会使得漏斗的延迟减少1pt，从而是无延迟的。这意味着上下两路都仅花费1pt，活塞同时收回。

Sancarn和Selulance所做的诸多实验都指向一个事实，漏斗既非如中继器、比较器一类的非同步元件，又非如活塞一类的同步元件。漏斗更新的位置介于Block Event和下一游戏刻的Next Tick Entry之间，而掉落沙实验证明，漏斗更新的位置位于Entity Update之后。这与我们在《基础红石原理》中认识到的更新顺序一致。

漏斗在Tile Entity事件工作，当漏斗被撤销激活时，会立即在下一个Tile Entity事件漏下一个物品，不过在时间轴顺序中，Tile Entity事件离活塞刻节点非常接近，因此大部分激活方式在更新到漏斗前都要先经过一个活塞刻节点，因此大部分激活方式都会使漏斗产生1pt的延迟。不过仍然有一小部分时间介乎于活塞刻节点与Tile Entity事件，Entity Update事件就是这样的。Entity Update事件提供信号下降沿时，按照更新顺序，漏斗会在下一个Tile Entity事件漏下物品，而没有跨过活塞刻节点，这就出现了我们上述实验中漏斗延迟消失的现象。

这是一个具有启示意义的结论，因为我们知道玩家的活动是在Network Update事件进行更新，而其他实体的更新是在Entity Update事件，因此，利用漏斗，便可以做到检测一个实体是否是玩家。

同样的事情也发生在上升沿，也就是说，只要漏斗被撤销激活，总会在下一个Tile Entity事件处理第一个物品，无论是取出、漏下、吸入物品。因此对于大部分输入方式，漏斗具有同步性，延迟为1pt，对少部分事件，漏斗没有延迟。而使用比较器检测漏斗时，无论是检测上升沿、下降沿，或是检测漏斗本身、上方的容器、指向的容器，信号都是同步的，比较器延迟恒为1pt，并输出一个在Next Tick Entry事件的非同步信号。

以上结论只适合于漏斗处理第一个物品，当漏斗持续地工作时，延迟为8gt。

## 漏斗理论

事实是，漏斗和中继器等NTE元件有着类似的工作方式，漏斗有着8的冷却值倒计时，这和中继器有着2、4、6、8的冷却值倒计时类似。每游戏刻的Tile Entity事件，漏斗的冷却值倒计时都减少1，接着漏斗都要检查自己的冷却值倒计时，为0时尝试处理物品，并在处理成功时将冷却值倒计时重设为8，否则没有任何响应。中继器只会在激活与撤销激活时使用它的冷却值倒计时，而漏斗无时不刻运行着它的倒计时。

当漏斗的冷却值倒计时为0，但漏斗没有物品可供处理时，漏斗不会将冷却值倒计时设为8而是保持在0，这意味着漏斗会在之后的每一个Tile Entity事件尝试处理物品，包括吸入、漏下、取出物品。

很明显，这个新的理论是兼容漏斗被撤销激活时的行为的，因为漏斗冷却值倒计时为0时，自然是在下一个Tile Entity事件立即尝试处理物品。

[>_<]:
漏斗还有一个奇怪的特性：当漏斗的冷却值倒计时小于等于1时，以非玩家方式放入物品时，漏斗的冷却值倒计时会被重置为8。这一特性已被实验证实。

```Java
@Override
    public void tick() {
        if (this.level == null || this.level.isClientSide) {
            return;
        }
        --this.cooldownTime;
        this.tickedGameTime = this.level.getGameTime();
        if (!this.isOnCooldown()) {
            this.setCooldown(0);
            this.tryMoveItems(() -> HopperBlockEntity.suckInItems(this));
        }
    }

    private boolean tryMoveItems(Supplier<Boolean> supplier) {
        if (this.level == null || this.level.isClientSide) {
            return false;
        }
        if (!this.isOnCooldown() && this.getBlockState().getValue(HopperBlock.ENABLED).booleanValue()) {
            boolean bl = false;
            if (!this.isEmpty()) {
                bl = this.ejectItems();
            }
            if (!this.inventoryFull()) {
                bl |= supplier.get().booleanValue();
            }
            if (bl) {
                this.setCooldown(8);
                this.setChanged();
                return true;
            }
        }
        return false;
    }
```

通过漏斗理论，我们可以解释如下的现象：漏斗内物品的流动情况与两个漏斗的放置顺序有着一定区别。现在在上方漏斗放入一定量的物品。

![](assets/方块更新与延迟理论的拓展-c71e1370.png)

当下方漏斗先被放置时，其首先更新。下方漏斗内没有物品，其取出上方漏斗的一个物品。紧随其后，上方漏斗将物品送入下方漏斗。整体效果就是每8游戏刻上方漏斗减少2个物品。

当上方漏斗先被放置时，其首先更新，将物品送入下方漏斗，而下方漏斗会因此将冷却倒计时重置为8，在这一游戏刻中，冷却倒计时被减少为7。7gt后，下方漏斗将其中的物品放入箱子，再将一个物品从上方取出。8gt时，上方漏斗再将一个物品放入下方漏斗之中。因此物品虽然也是两个两个向下流的，但这两个物品间存在1gt的时间差。

《基础红石原理》对漏斗时钟有了初步的介绍，下面有必要详细计算漏斗时钟的周期。

如下是一个尚未放入物品的漏斗时钟。

![](assets/方块更新与延迟理论的拓展-cbb27eda.png)

现在假设漏斗时钟中有一个物品在流动。当漏斗将左侧物品送入右侧，2游戏刻后活塞开始伸出，右侧漏斗解锁，7游戏刻时右侧漏斗将物品漏回左侧。同理，14游戏刻时物品再次送往右侧，周期为14gt。

现在假设漏斗时钟中有两个物品在流动，左侧和右侧漏斗各有一个物品，红石块锁住右侧漏斗，现在左侧漏斗将物品送入右侧漏斗，左侧漏斗内空。2gt后，比较器熄灭，活塞开始推出，红石块位置移动，右侧漏斗会在这一游戏刻将物品送回左侧漏斗，第二个物品则需要8gt。同理，恢复原位需要同样的10gt，总延迟为20gt。

当漏斗内物品多于2个时，计算就和两个相同了。除了移走红石块同时流入的物品，其他物品都需要8gt来传输，比较器则需要2gt，当漏斗内共有n个物品时，漏斗时钟的周期为16n-12 gt。

除了漏斗时钟外，另外一种常用的时钟是漏斗链时钟。

![](assets/方块更新与延迟理论的拓展-3af5cef5.png)

漏斗链时钟最大的特点在于无论不会因输入控制而产生混乱，因为拉杆仅控制一个漏斗的激活状态。拉杆拉回时，物品在漏斗链中循环，拉杆拉下时，物品会在若干游戏刻后被锁在开关控制的漏斗中。而下面的中继器时钟虽然拥有相同的周期，但想做到这一点就比较困难了。

![](assets/方块更新与延迟理论的拓展-2d1b5bbc.png)

漏斗链时钟中，大多数漏斗都是空着的，这意味着漏斗可以在接收到物品的同一游戏刻进行一次更新，随后7游戏刻将无碰撞送入下一漏斗。对n的漏斗的漏斗链时钟，周期为7n gt。

漏斗移位器的原理与漏斗链时钟类似，向被锁住的漏斗链中输入短负脉冲，这一信号仅允许物品移动一个漏斗，从而达到移位的功能。

![](assets/方块更新与延迟理论的拓展-002411ca.png)

# 第五节 0t脉冲

## 0t脉冲的细化

《基础红石原理》介绍了若干短脉冲，主要侧重于短脉冲作用于粘性活塞的若干情形，下面对0t脉冲进行细化。

在一个标准游戏刻中，选取不同的事件充当上升沿和下降沿，就可以获得不同类型的短脉冲。除去Network Update事件，分别以其余五个事件作为上升沿和下降沿，便可以得到25种0t脉冲。这里的0t脉冲是相较于标准游戏刻长度而言的，有些0t脉冲甚至跨过了游戏刻节点，也可以被称为1gt脉冲；而有些0t脉冲由于无法使活塞响应，也可以被称为短0t脉冲。0t脉冲就是这样的一个种类丰富的大家族。

不同元件对不同0t脉冲会有不同的反应，在《基础红石原理》中我们就已经认识到，中继器总会响应0t脉冲，无论它有多短；而比较器和红石火把则会在点亮前先检测是否仍有信号，否则不会亮起；活塞顺推的延迟取决于经过的Block Event事件个数。举例来说，NTE-TE的0t脉冲使得粘性活塞在本游戏刻的Block Event事件开始伸出，下一游戏刻的Block Event事件伸出完成，也就是1pt顺推；NTE-BE的0t脉冲使得粘性活塞在本游戏刻的Block Event事件开始推出并推出完成，也就是0t顺推；而NTE-NTE的0t脉冲不经过Block Event事件，活塞不会响应。

红石线、动力铁轨、活板门、栅栏门等方块都是即时响应的，同时游戏总会播放栅栏门等开关的音效，但游戏会渲染其是否亮起或是否打开则是在Block Event事件之前，换句话说如果希望红石线闪烁或栅栏门打开，所使用的的0t脉冲就必须经过Block Event事件之前，如NTE-BE脉冲或NTE-TE脉冲，而BE-BE脉冲就不能让红石线闪烁。这一点至少对于1.12-1.13是成立的。~~（在1.15中似乎在NTE前更新，有待考据）~~

*例 分析如下的短脉冲发生器，按下按钮，判断中继器和粘性活塞的响应情况。*

![](assets/方块更新与延迟理论的拓展-406d1ed2.png)

*很明显，这是一个NTE-BE脉冲，中继器响应，粘性活塞0t顺推。*

*例 分析如下的短脉冲发生器，拉回拉杆，判断中继器和粘性活塞的响应情况。*

![](assets/方块更新与延迟理论的拓展-e320c52d.png)

*很明显，这是一个TE-NTE脉冲，中继器响应，粘性活塞无响应。*

## 活塞更新深度

由于红石线更新具有随机性，如下的装置无法准确判断拉杆拉下后的情况。

![](assets/方块更新与延迟理论的拓展-b0a72c33.png)

但如下的装置却并非如此，两个面对面的活塞处于BUD态，谁可以伸出取决于谁先受到更新。在拉杆拉下时，其后的四个普通活塞激活，可以确定这四个活塞从左向右更新，因此左侧活塞一定可以伸出而右侧无法伸出。

![](assets/方块更新与延迟理论的拓展-752f76cf.png)

和NTE元件类似地，每游戏刻中的Block Event事件，所有需要更新的活塞也会被加入一个列表，但这个列表的更新顺序并不仅仅取决于活塞加入列表的顺序，还取决于活塞更新的深度。活塞更新的深度指的是从信号源到活塞间需要几个活塞作为更新，如上图后侧的四个普通活塞，深度分别为0,1,2,3。深度小的一定优先于深度大的更新。这一过程被称为广度优先。

那么读者不难理解如下的装置，左侧在下降沿是一个BE-BE脉冲发生器，其下6个活塞深度从右至左分别为0,1,2,3,4,5。

![](assets/方块更新与延迟理论的拓展-e86f21c5.png)

BE-BE脉冲于0深度活塞开始收回后产生，5深度活塞开始收回后结束。0深度活塞不仅会更新到1深度活塞，其还会更新到右侧的脉冲深度检测器，深度检测器中最左侧的活塞也会是1深度的，而受其影响，深度检测器中的活塞从左到右分别为1,2,3...且脉冲发生器中的各活塞优先于同深度的深度检测器中的活塞更新。因此右侧仅有深度为1-4的活塞会响应。

![](assets/方块更新与延迟理论的拓展-5360ac8e.png)

因此，如果希望激活右侧的两个活塞，左侧的短脉冲发生器需要使用4个活塞。

![](assets/方块更新与延迟理论的拓展-669d9885.png)

## 超频时钟（还没写）
