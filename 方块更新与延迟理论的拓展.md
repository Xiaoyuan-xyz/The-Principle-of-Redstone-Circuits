在基础红石原理中，我们将方块的亚稳态称为BUD态，能够更新处于BUD态的方块的信号称为方块更新信号，能够检测方块更新信号的装置称为BUD。但事实上，其他的一些装置如TEUD，观察者等似乎可以对其他信号做出相应，这意味着游戏存在更多类型的方块更新信号。对更多更新信号的研究对方块更新理论进行了拓展。

TEUD是一种BUD，但不同于常规BUD，它检测的内容不止是方块更新，本质上与BUD“检测方块更新”这一最初的概念不相符合，因此BUD这一词的概念应当有所扩大。现在我们认为，BUD是一种直接或间接检测方块发生的变化的装置，检测方块更新信号的BUD称为常规BUD，其余称为非常规BUD。在一些资料中，常规BUD被直接简称为BUD，《基础红石原理》也是这样做的。而现在BUD一词已经拥有较多含义，为使读者不至混淆而产生歧义，本书之后不再做这种简称。TEUD就是最典型、最常见、最具有代表性的非常规BUD。

基础的延迟理论旨在解释红石元器件和活塞的运行规律，但游戏中的红石元件显然不仅限于此。漏斗和观察者也是非常重要的红石元件，延迟理论的拓展将主要研究这两个元件。

<!-- TOC depthFrom:1 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 -->

- [第一节 TEUD](#第一节-teud)
	- [TEUD的简介](#teud的简介)
	- [TEUD的制作](#teud的制作)
	- [TEUD的功能](#teud的功能)
- [第二节 观察者](#第二节-观察者)
	- [观察者的输出特性](#观察者的输出特性)
	- [观察者的输入特性](#观察者的输入特性)
- [第三节 方块更新信号](#第三节-方块更新信号)
	- [方块更新信号与方块变化的辩证关系](#方块更新信号与方块变化的辩证关系)
	- [红石线更新顺序](#红石线更新顺序)
		- [空间稳定性](#空间稳定性)
		- [方块更新顺序](#方块更新顺序)
		- [红石线与哈希算法](#红石线与哈希算法)
		- [特异点](#特异点)
		- [方块更新和深度优先](#方块更新和深度优先)
		- [线路稳定性](#线路稳定性)
	- [NC更新与PP更新](#nc更新与pp更新)
	- [更新抑制](#更新抑制)
- [第四节 漏斗理论](#第四节-漏斗理论)
	- [漏斗概述](#漏斗概述)
	- [即时更新理论对漏斗的修正](#即时更新理论对漏斗的修正)
	- [漏斗理论](#漏斗理论)
- [第五节 0t脉冲](#第五节-0t脉冲)
	- [0t脉冲的细化](#0t脉冲的细化)
	- [活塞更新深度](#活塞更新深度)
	- [超频时钟](#超频时钟)

<!-- /TOC -->

# 第一节 TEUD
## TEUD的简介

TEUD（Tile Entity Data Update Detector），又称DUD（Data Update Detector）或CUD（Comparator Update Detector），即比较器更新检测器，是一种BUD的拓展衍生物，其检测的不只是方块更新信号。

游戏需要检测方块是否处于正常的状态，因而有了方块更新信号，检测方块更新信号的检测器就是方块更新检测器。同样，比较器具有满箱检测的功能，其可以检测容器、炼药锅、物品展示框、末地传送门框架及探测铁轨上的矿车等诸多项目，可以预想到这些项目的检测依赖于另一种更新信号，也就是比较器更新信号，检测比较器更新信号的检测器就是比较器更新检测器了。TEUD的核心元件是比较器，因此TEUD比常规BUD有更广的检测范围。

最早已知且仍然稳定可用的一种TEUD实现是由NiceMarkMC给出的，时间不晚于2013年5月初。在此之前的若干研究与讨论都为TEUD的成型做出了铺垫。

比较器更新信号具有和方块更新信号不同的性质。最大的不同就是方块更新信号一般的更新范围是方块的毗邻，即使红石元件有较大的更新范围，这个更新范围也是由产生更新的方块主导的；比较器更新信号则允许更新信号沿四周的实体方块传递一格，如果不存在实体方块，比较器更新信号也就不会产生。这显然是因为比较器可以通过实体方块进行满箱检测。

## TEUD的制作

TEUD的核心是陷入BUD态的比较器，而TEUD必须实现自复位功能，这是TEUD的根本原理。让比较器陷入BUD态的方式多种多样，但大多数方案都使用了比较器检测的功能。其中，箱基TEUD的制作最为简便。

箱子可以被红石比较器直接检测或隔着一个实体方块被红石比较器检测，当箱子内有物品且箱子没有被实体方块压住时，比较器才会输出信号。如果在内含物品的箱子上方拿实体方块压住箱子，比较器理论上讲应该会熄灭，但是由于这一行为往往无法更新到比较器，比较器就会陷入BUD态。这样一来，比较器就可以检测比较器更新信号了。用活塞控制实体方块压箱子可以将这一原理自动化。下图就是一个箱基TEUD。当更新比较器时，比较器熄灭，活塞收回，收回结束更新到比较器，比较器点亮，活塞伸出，压住箱子，TEUD复位。

![](Illustration/方块更新与延迟理论的拓展/方块更新与延迟理论的拓展-2e508404.png)

若使得箱基TEUD的活塞不会更新到比较器，便可以制作出双稳态箱基TEUD，可以使用大箱子做到这一点。

![](Illustration/方块更新与延迟理论的拓展/方块更新与延迟理论的拓展-880a3460.png)

物品展示框可以被比较器检测。物品展示框作为一个实体可以与其他碰撞不完整的方块共处一个方块内，但是此时比较器无法检测物品展示框，因此可以做出TEUD。 值得一提的是，这是一个双稳态TEUD。

![](Illustration/方块更新与延迟理论的拓展/方块更新与延迟理论的拓展-f85f8547.png)

炼药锅可以用于制作TEUD，其可以被比较器检测，但重点在于其可以被活塞移动，这就给出了一种极佳的自复位方法。

![](Illustration/方块更新与延迟理论的拓展/方块更新与延迟理论的拓展-a2d9feec.png)

比较器可以检测探测铁轨上的矿车，而粘性活塞可以移动探测铁轨。这一过程主要是探测铁轨在产生比较器更新信号。

![](Illustration/方块更新与延迟理论的拓展/方块更新与延迟理论的拓展-f1de4f0a.png)

箱基TEUD也可以不使用实体方块而使用猫，猫会主动坐在箱子、床及燃烧的熔炉上，当猫坐在箱子上时，箱子无法被打开，比较器也无法进行检测。

![](Illustration/方块更新与延迟理论的拓展/方块更新与延迟理论的拓展-f8955afc.png)

利用红石指向BUD可以使一切输出元件陷入BUD态，比较器也不例外。

![](Illustration/方块更新与延迟理论的拓展/方块更新与延迟理论的拓展-c3f44a3d.png)

## TEUD的功能

在TEUD中，比较器陷入了BUD态，这意味着TEUD也能检测常规BUD所能检测的事项，为将比较器更新信号从方块更新信号中分离出来，我们可以利用比较器更新信号特殊的传递方式，隔着一个实体方块用特定事项更新比较器，这一过程称为TEUD的分离，隔着一个实体方块使TEUD动作的过程称为TEUD的响应。但红石元件往往具有较大的更新范围，即使隔着一个实体方块有时也无法成功分离方块更新信号和比较器更新信号，这种情况称为TEUD的分离失效。

在排除TEUD分离失效的情况下，TEUD可以分离出许多比较器更新信号，从这一点来说，TEUD可以使纯红石系统的认知范围扩大。BUD现象的出现证实了游戏内存在方块更新信号，而TEUD则证实了游戏内存在着另一种更新信号——比较器更新信号。如果没有常规BUD和TEUD，这些更新信号像幽灵一样在游戏内运行而无法为人感知。因此是某些方块的变化，产生了特定的更新信号，这些更新信号由常规BUD或TEUD检测，才间接得知方块变化的发生，这是常规BUD和TEUD扩展纯红石系统的认知范围的原理。

TEUD主要检测容器及类容器的“内容物”发生变化。TEUD会响应箱子、熔炉、酿造台等容器的内容物信息变化。放置或破坏容器、直接取走或放入物品、通过漏斗取走或放入物品、投掷器或发射器投出物品、用其他物品替代已有物品甚至是在容器内左键或右键均会使TEUD响应。投掷器的空投、按住Shift左键或右键容器内部、打开和关闭容器、在容器内拖动左键或右键但不放开不会造成内容物的变化，TEUD不会响应。工作台、末影箱、花盆和音符盒不是容器，TEUD不会响应。

“类容器”是指类似容器的方块或实体，其没有类似箱子的GUI界面，但仍可以存储比较器可以检测的信息。其中如炼药锅、末地传送门框架等方块利用方块数据值存储信息，唱片机等方块使用方块实体值存储信息，物品展示框使用实体数据存储信息。探测铁轨可以“容纳”矿车，可以把探测铁轨也视为类容器，本小节会在最后对其进行研究。类容器方块会在被放置时产生比较器更新信号，破坏时不会产生；物品展示框在放置时不会产生比较器更新信号，破坏时会产生。

以下展示了常见的TEUD响应项：

- 将末影之眼放入末地传送门框架
- 将唱片插入唱片机或从中取出
- 炼药锅的水位变化
- 在讲台上放置或取下书籍、翻书

不过由于比较器本身就可以检测类容器的“内容物”变化，TEUD在这些项目的检测上并没有带来新的拓展。

TEUD和探测铁轨搭配时，会产生令人吃惊的效果：TEUD不再检测容器的内容物，转而成为一个实体检测器——当探测铁轨所在方块与某一实体碰撞箱有交集时，TEUD便会响应。因此，即使是浮空的实体也会触发TEUD。物品展示框、闪电不会使TEUD响应。如下图右侧的箭会触发TEUD，而左侧不会。

![](Illustration/方块更新与延迟理论的拓展/方块更新与延迟理论的拓展-f2c2be17.png)

如下是一个角度刁钻的例子：

![](Illustration/方块更新与延迟理论的拓展/方块更新与延迟理论的拓展-eb1ef670.png)。

当实体与探测铁轨所在的方块接触时，实体会促使探测铁轨发出比较器更新信号，除箭外，这个信号是周期性的，但不同实体的周期不同：所有矿车的周期是20gt;物品为6gt；生物、钓鱼竿吊钩等大多数实体的周期为4gt；玩家的周期小于4gt，可以认为小于TEUD的自复位时间；箭只会在射到其上时产生1次比较器更新信号。~~（在这一方面似乎需要更多的研究。）~~

![](Illustration/方块更新与延迟理论的拓展/方块更新与延迟理论的拓展-1e2721d3.png)

# 第二节 观察者

观察者拥有一个检测端和一个输出端，其中检测端可以检测检测面方块的方块变化。当观察者认可该方块变化时，以15强度强充能其指向，给予毗邻及指向的毗邻方块更新，脉冲长度为2gt。另外，放置观察者不会引起检测端输入。

虽然观察者的确可以对红石信号做出响应，但该响应是由于观察者检测到了方块变化，因而不认为观察者是输出元件，观察者是一个输入元件。

## 观察者的输出特性

观察者是一个NTE元件，优先级为0，有2gt的启动延迟，换句话说，其会在检测端输入后的第二个NTE事件开始输出信号，信号持续2gt，并在第四个NTE事件停止输出信号。在检测端输入到停止输出这段时间内，观察者无视一切方块变化。观察者开始输出信号时，先给予毗邻更新信号，随后输出15强度红石信号；结束输出信号时，先结束红石信号的输出，随后给予毗邻更新信号。*（有待考察）*

观察者的一个重要特性是观察者可以被活塞推动，下面介绍观察者被活塞推动时的输出特性。

- **当观察者处于未触发态时（包括启动延迟），若观察者被活塞推动，其会将推动结束的BE事件或TE事件作为观察者的检测端输入。**
- **当观察者处于触发态时，若观察者被活塞推动，其在结束推动后保持无信号输出。**

在1.11引入观察者后，狼顾之鬼怪才（Joker_小狼）在《观察者性质总结》中率先研究了观察者的诸多性质，如下的两道例题便引自该文献。

*例 2 计算上下路延迟，判断时序比较器的输出情况。*

![](Illustration/粘液块与观察者技术/1-3-1.png)

*解：粘性活塞启动延迟1gt，观察者启动延迟2gt，因而在观察者未触发时，粘性活塞开始推动观察者。推动结束后，观察者于TE事件开始进入启动延迟，启动延迟2gt，故上路延迟5gt。下路延迟4gt，从而时序比较器激活锁定。
由于时序比较器在延迟相等时处于未激活锁定，这就证明了上路延迟一定大于4gt，从而说明观察者在被活塞推动结束后，启动延迟仍为2gt。*

![](Illustration/粘液块与观察者技术/1-3-2.png)

*例 3 拉杆拉下后，TNT能否爆炸？为什么？*

![](Illustration/粘液块与观察者技术/1-3-3.png)

*解： 中继器延迟2gt，活塞无启动延迟，故活塞将在观察者触发的第一个BE事件推动观察者，推出结束后无信号输出，TNT不会爆炸。*

![](Illustration/粘液块与观察者技术/1-3-4.png)

下面介绍“脸对脸”的观察者时钟，这种时钟构造简单，在观察者被引入后得到了许多玩家的喜爱。

![](Illustration/粘液块与观察者技术/1-3-5.png)

两个观察者“脸对脸”，互相检测对方的变化，两个输出端给出的是互补的，周期为4gt，占空比为50%的高频时钟信号。一般配合粘性活塞来关闭或开启这种时钟。

下面应用红石更新延迟理论对该时钟进行分析。

拉杆拉下，粘性活塞有1gt启动延迟，随后粘性活塞于BE事件伸出，左边的观察者以此为检测端输入，启动延迟为2gt。其于拉杆拉下3gt，也就是第三个NTE事件开始输出信号。粘性活塞总延迟3gt，其于第三个NTE事件后的TE事件将右边的观察者推出到位，观察者以此作为检测端输入。5gt后，左边观察者结束输出，右面观察者开始输出，由于左边观察者于3gt NTE事件进入NTE列表，右边观察者于3gt TE事件进入NTE列表，左边观察者先于右边观察者更新，因此在5gt时，左边观察者先结束输出，右边观察者后开始输出。因此右边观察者由非触发态转变为触发态的方块变化可以被左边的观察者检测到，左边观察者重新进入启动延迟。两个观察者以此往复，可以得出周期为4gt，占空比为50%的结论。

![1-3-6 （草稿）](Illustration/粘液块与观察者技术/paint1.png)

一个有意思的现象是，如果第二个观察者不是由活塞推入的，而是由玩家放置的，我们可以明显觉察到时钟变慢了，而且可以观察到两个观察者同时熄灭的瞬间，此时时钟周期不再是4gt，而是更慢的6gt。

![1-3-7](Illustration/粘液块与观察者技术/1-3-7.png)

下面对玩家放置的观察者时钟进行分析。

玩家放置第二个观察者后，其本身不会响应，但第一个观察者会以此为检测端输入，2gt后，更新第二个观察者，同时自身开始输出信号。4gt后，第二个观察者开始输出信号，但第一个观察者结束输出晚于第二个观察者，故第一个观察者不会响应此次方块变化，而第二个观察者此时正处于激活态，不响应第一个观察者结束输出带来的方块变化。第一个观察者会在6gt后检测到第二个观察者结束输出的方块变化，并以此往复。

![1-3-8（草稿）](Illustration/粘液块与观察者技术/paint2.png)

## 观察者的输入特性
观察者的输入特性指的是观察者会对怎样的方块变化产生响应，亦即观察者可以检测到哪些方块变化。在1.15版本(1.13+)中观察者的输入特性较为简单，可以被总结为：

> **观察者检测一切方块名称和状态的变化。**

在1.13的扁平化进程后，方块的英文ID被用来区分不同的方块，不同的方块一定有着不同的英文ID；方块的数据值用于区分同一方块的不同状态，如不同朝向的火把，或不同水量的炼药锅；方块的实体值用于记录方块的附加属性，如告示牌的文字，或箱子里的物品。那么，观察者检测是的英文ID的变化及方块数据值的变化。一切ID的变化或数据值的变化都能引起观察者的响应。打开F3界面可以轻易看出这一点。

从观察者的引入到特性逐渐稳定，期间经过了若干个版本，但最后的观察者所保留的特性是较为简明的，我们可以简单地理解为：

> **观察者并不检测方块更新信号，观察者响应方块变化。**

即使如此，我们仍有必要对一些特殊的示例具体分析。

由于观察者检测的是方块变化，而非方块更新，而活塞推动方块会在开始推动时就将趋势位设置为36号方块，观察者就可以捕捉到这一变化。因此右侧的两个红石灯会同时亮起，而左侧的两个红石灯会有3gt的延迟差，这3gt相差在了前一个活塞的2gt推出延迟和后一个活塞的1gt启动延迟。

![1-3-9](Illustration/粘液块与观察者技术/1-3-9.png)

投掷器和发射器以及漏斗，在F3界面的triggered或enabled数据值往往不能反映其的真实状态，需要玩家查看其内容其才能被更新到正确的值，暂不明确这是否为一个bug。但观察者可以正常检测投掷器、发射器和漏斗工作状态。特别是投掷器的空投和漏斗的锁定解锁，这是非观察者所不能检测的。

![1-3-10](Illustration/粘液块与观察者技术/1-3-10.png)

栅栏，红石线，拌线等方块是依据自身的方块数据值来区分自己的连接情况的，因此观察者可以检测这些方块的连接状态是否发生改变，例如下图1的装置就可以区分一个方块能否与栅栏相连接，而下图2的示例中，无论破坏哪一个红石线，观察者都会响应。
![1-3-11](Illustration/粘液块与观察者技术/1-3-11.png)

![1-3-12](Illustration/粘液块与观察者技术/1-3-12.png)

酿造台的数据值仅用于说明酿造台当前的瓶子数量及位置，因此观察者也只能检测这些。

![1-3-13](Illustration/粘液块与观察者技术/1-3-13.png)

在1.13的扁平化进程后，树叶使用1-7的distance数据值用于标明其与最近原木的距离，这个值最大是7。同理，观察者可以检测到树叶distance数据值的变化，这一特性最早由2No2Name于2018年7月23日发现。关于观察者检测树叶，下一节会做更多详细的描述。

![1-3-14](Illustration/粘液块与观察者技术/1-3-14.png)

脚手架于1.14被加入游戏，值得注意的是其拥有的两个数据值——bottom数据值和distance数据值。bottom数据值用于指示脚手架下方的方块是否能够支撑脚手架，0-7的distance数据值用于标明其累计横向拓展的距离，最大可以拓展6格，这个数据值与树叶的distance数据值具有相似的性质，但其只计量横向距离。观察者自然可以响应这两个数据值的变化。

![](Illustration/粘液块与观察者技术/粘液块及观察者技术-ee5f1bdd.png)

可含水方块拥有waterlogged数据值，水流拥有level数据值，观察者可以检测这些方块或流体的数据值变化。

![1-3-15](Illustration/粘液块与观察者技术/1-3-15.png)

# 第三节 方块更新信号

## 方块更新信号与方块变化的辩证关系

面对常规BUD，我们可以说某些方块变化引起了方块更新信号，从而更新常规BUD，使其响应。也可以说常规BUD检测某些相对位置上特定的方块变化，这就是方块变化与更新信号的辩证关系。实践证明这种关系在研究观察者的检测时提供了很好的思维动力。换句话讲，我们不再关心方块更新的底层实现，而只把BUD作为拓展纯红石体系认知能力的一种手段。

事实上，这种思想在输出元件的激活上也有体现，我们分别使用两种角度对待元件的激活：红石灯等较为简单地元件使用的是“红石线激活红石灯则亮起”的思路，而活塞等实则是“活塞激活位上有信号则推出”的思路。我们把这一点类比到方块更新理论中。从更新信号的角度看，是方块变化引起更新信号，不同的更新信号更新到不同类型的BUD，从而使其响应。从方块变化的角度，是不同类型的BUD检测特定的方块变化项，在属于这个特性方块变化项集合的某一个方块变化项发生时，该类型BUD响应。

而现在，我们认为，全部的方块变化依赖某一种类型的方块更新信号而产生影响，而全部的方块更新信号是由于特定位置的方块发生了某种变化。这样看来，观察者所响应的方块变化也可以被视作一种方块更新信号，这种更新信号仍被称作方块变化，因此即可以说“观察者响应方块变化”，也可以说“观察者检测方块变化”。以下我们总把方块变化视作一种更新信号。BUD装置的存在揭示了某种类型的方块更新信号，有一种形式的BUD就对应一种形式的方块更新信号，而该类的BUD正是为了检测该类方块更新信号而生。

那么，什么样的方块变化能够引起一类BUD的相应呢？很不幸，这两者之间没有绝对的关系。

举例来说，红石元器件所产生方块更新信号范围都较大因而产生BUD覆盖，例如红石线的强度变化，TEUD和常规BUD会有相同的响应。漏斗传输物品并不会产生方块更新，因此能被TEUD分离，而且漏斗内部的物品变更，本身就是一个方块变化，因此可以被观察者检测。投掷器的撤销激活不会产生任何方块更新或附加值更新信号，其内部的物品甚至没有变化，但是我们曾在投掷器的激活判定一节中提到：投掷器被激活后会变为激活的投掷器，撤销激活会变回。这显然是一个变化，可以用观察者检测。而中继器充能方块激活红石线的过程，实质上是中继器借助了实体方块而激活红石线，我们只把这种充能看做玩家对电路的分析方式，实体方块本身并没有什么变化，因此不会被观察者响应。

通常来说，常规BUD、TEUD、以及观察者的检测范围都是不一样的，需要根据不同的需求采取不同的检测方式。而观察者也带来了超出方块更新体系的一面，观察者作为可移动的信号方式，并且有着奇特的激活方式。这样说来，观察者是1.11加入的新方块，其具有的特殊价值，以及新的利用方式还有待玩家积极开发，观察者有着非常大的应用前景。

## 红石线更新顺序

### 空间稳定性

一个很无奈的事实是，如下的装置具有空间随机性，玩家无法预测装置的行为。

![](Illustration/方块更新与延迟理论的拓展/方块更新与延迟理论的拓展-d2ab6124.png)

即便如此，玩家依然尝试寻找该装置背后的规律，尤其是在活塞被引入游戏的若干年后。最简单的想法就是将上图的装置在各处测试，以期发现装置运行和位置、方向以及其他一些相关因素之间的规律。即使这样的实验很多人都做过，即便他们将控制变量法运用到精细到可怕的程度，但得到的无非是一些诸如“红石线熄灭时，大致是由远至近更新的”这样模棱两可的规律。事实是，许多人都追求理论的完整、精细甚至是复杂，但真正令人遗憾的是他们都忘记了研究应当经历一个从简单到复杂，从具体到普适的过程。在这一“竞争”现象被发现的两三年内，没有人提出应当从单个点状红石开始实验，研究方块更新产生的顺序。

然而，几个与稳定性有关的名词却伴随实验逐渐映入玩家们的眼帘，并成为了如今玩家所熟识的常识。

- **空间稳定性**：如果一个装置具有空间稳定性，则意味着装置不会随位置的改变而产生不同的运行结果。大多数方块更新理论和延迟理论都是在空间稳定性的前提下进行研究的。如果某一现象不遵循空间稳定性，玩家会尝试修改装置使之成为空间稳定的装置。空间稳定性包括平移稳定性，后者指某一装置不会因平移而改变行为。除此之外，有不少装置具有方向性，即不能在旋转下保持行为不变（没有旋转稳定性）。还有一些装置会在区块的边缘运行失败。
- **时间稳定性**：如果一个装置具有时间稳定性，则意味着相同的装置在相同的位置运行，无论运行多少次，总会得到相同的结果。除了刻意被设计为具有随机性的元件（如投掷器、发射器）外，其他元件、装置、理论、Java版整体都具有时间稳定性。这是Java版和基岩版红石电路最大的不同之处——基岩版不具有时间稳定性。
- **版本稳定性**：游戏具有版本稳定性，这意味着即使是不具有空间稳定性的装置，在相同版本（包括游戏版本和Java版本）也会具有相同的表现。这说明理论对于不同计算机是普适的，因为在相同版本之下，游戏的内容和运行环境是相同的。

### 方块更新顺序

下面考察单个点状红石对其毗邻进行方块更新时的顺序。为了保持版本稳定性，我们使用1.15.2（至少包括1.13-1.15.2，可能包括1.5-1.15.2）和Java8。

在如下的装置中，拉下拉杆，红石线激活，开始更新活塞，而活塞激活的顺序就可以反映出红石线进行方块更新的顺序。实验证明，该装置具有平移稳定性，且在不同朝向上的运行有规律可循。

![](Illustration/方块更新与延迟理论的拓展/方块更新与延迟理论的拓展-5a572430.png)

事实上，所有方块更新（1.13后，NC更新）对毗邻进行更新的顺序都是相同的，以下称之为**方块更新顺序**，即：**西、东、下、上、北、南**，或 **-X、+X、-Y、+Y、-Z、+Z**，或**W、E、D、U、N、S**。因而如果上图面朝北方的话，总会是右手侧，即东侧活塞伸出，因为E要优先于N更新。这也是放置方块和破坏方块产生方块更新的顺序。

对于其它方向，我们可以采用处于BUD态的活塞配合命令方块来进行实验。

![](Illustration/方块更新与延迟理论的拓展/方块更新与延迟理论的拓展-d7119261.png)

红石元件通常具有较为特殊的更新范围，如下是《基础红石原理》中曾出现的一道例题，其证明中继器激活时只以指向为中心更新一阶毗邻。现在指出，这种更新也遵循上述更新顺序规律，只是唯独不更新信号的来源方向，也就是中继器本身。遗憾的是目前没有实验可以证明这一点。如果下述中继器指向东侧，那么更新顺序就是：东、下、上、北、南。

![](Illustration/方块更新与延迟理论的拓展/方块更新与延迟理论的拓展-6911cbcf.png)

红石线的更新就要复杂得多，这是因为点状红石在激活时会更新二阶毗邻，具体实现过程为将本身及一阶毗邻共七个位置作为更新源，每一个更新源都遵循如上的方块更新顺序，但七个更新源之间的先后顺序，也就是**更新源顺序**是随机的，这也是“红石线瞎更新”真正“瞎”的地方。

*例 面朝北方，拉下拉杆尝试分析如下装置的运行结果。*

![](Illustration/方块更新与延迟理论的拓展/方块更新与延迟理论的拓展-15797f39.png)

*在如上的电路中，两个活塞都不处于点状红石的一阶毗邻，故我们必须考虑点状红石的七个更新源，在这里，东侧更新源可能更新到右方活塞，而北侧更新源可能更新到前方活塞。如果东侧更新源先更新，毫无疑问右方活塞先伸出；如果北侧更新源先更新，根据方块更新顺序，E将优于N，也会是右方活塞先伸出。综上所述，右方活塞先伸出*

*有的读者可能会有疑惑：“东侧更新源不是空气吗，难道红石信号可以穿过空气传给活塞吗”？这里必须注意，充能理论是玩家用于分析电路所提出的理论，实体方块并不存在充能态和非充能态。拉下拉杆后，不存在一个时刻之后实体方块就被充能了，而是如果活塞收到更新，其会检测自己是否应该伸出。方块更新信号并不区分实体方块或非实体方块。在这里，无论哪个更新源先更新，都是北侧实体方传递红石信号。*

以下我们提到更新源时，会将原位更新源记作O，毗邻更新源分别记作+X、-X、+Y、-Y、+Z、-Z。希望读者不要混淆方块更新顺序和更新源顺序。

上述装置几乎具有空间稳定性，在面朝北方或南方，装置总会使右方活塞先伸出；而东方或西方也几乎是这样，只有极为特殊的几个点，会使得前方活塞先伸出。下图左侧就是一例。这暗示我们，红石线的更新源顺序还有更深层的规律可寻。

![](Illustration/方块更新与延迟理论的拓展/方块更新与延迟理论的拓展-b0dac3f9.png)

最后，实验证明，**某点处红石线更新源顺序仅与该红石线所在的绝对坐标有关**。

### 红石线与哈希算法

sharir1701在2015年发表了《红石更新顺序》，指出红石线存在随机性的原因是其使用了数据结构中的HashSet，并尝试以此解释某些红石线的更新现象。

HashSet是一种哈希表（hash table），最底层是一个数组，对象可以存入其中，就像标了序号的许多格子。序号的计算需要通过散列函数，也就是通常所说的**哈希函数**，其可以为对象计算得出尽可能随机的哈希值，随后依据哈希值对数组长度取余得到序号，将对象存储在哈希表中。读者只需知道，这有利于对这些对象进行查找、插入和删除。

对象的哈希值仅取决于对象本身，相同的对象总会得到相同的哈希值。不同的对象也可能拥有相同的哈希值，这被称为冲突，但一般情况下这种事情发生的概率较小，在HashSet中，如果对象拥有相同序号，会被存到同一个格子中挂成一串，新加入的对象被挂在末尾。

HashSet的数组默认长度为16，当存储的对象过多时便会考虑扩列，但在存储红石线的更新源是一件模式固定且简单的事，不会扩列，本被设定为无序的HashSet也呈现出一定的规律。

在红石线更新源中，一个坐标的哈希值的计算公式由游戏决定，应用如下公式计算：

```Java
h = x + 31 * (y + 31 * z)
```

通过哈希值计算坐标在数组中存储序号的公式由Java决定，应用如下公式计算：

```java
hash = h ^ (h >>> 16);
n = (length - 1) & hash
```

关于上述公式，有以下几点需要解释和注意：
- Java在运行时，所有数字都以二进制存储，因而有一个取值范围，也就是32个二进制位所能表示的数字。在这里可以认为取值范围是 $[0,2^{32})$ ,即0~4294967295，超出这个范围的会取余数，例如-1便会被存储为4294967295，表示为二进制就是`1111 1111 1111 1111 1111 1111 1111 1111`。
- 哈希值的计算仅与坐标有关，且更新源顺序仅与哈希值有关，因此**某点处红石线更新源顺序仅与该红石线所在位置的哈希值有关**。例如(0,64,0)处的红石线应当与(31,63,0)处的红石线有相同的表现，因为二者的哈希值相同，都是 $64\times31=1984$。
- 关于Java中从哈希值计算序号的具体方式将放在最后，这里只通过例子介绍序号的计算方式。如果要求的坐标为(100,64,2000)。
	- 首先计算哈希值，$h=100+31\times(64+31\times2000)=1924084$。
	- 将哈希值除以65536，再求16的余数，即 $1924084=29\times65536+23540, 29=1\times16+13$，最后我们需要的就是这个13。它代表了高16位。
	- 将哈希值对16取余数，即 $1924084=120255\times16+4$，这次需要的是4。它代表了低16位。
	- 将刚才计算得出的两个数表示为二进制，即1101和0100，再做一次异或操作，即对应位如果相同则取0，不同则取1，最后得到1001，也就是9，这个坐标的序号就是9。

*如果需要对理解代码的实现方式，可以阅读本条目。不要求一般的读者掌握。*

- *`h >>> 16`是Java中的无符号右移16位的意思，可以理解为取高的16位，如`1010 1010 1010 1010 1100 1100 1100 1100`无符号右移16位得到的结果就是`0000 0000 0000 0000 1010 1010 1010 1010`，换句话说是这个数字除以65536所得到的商。*

- *`^`是按位异或，在这里表示将哈希值和哈希值的高16位进行异或。这一操作的目的是让结果更加散列。*

- *如前所说，存储红石线更新源是一个十分简单的模式，不会扩列，这里`length = 16`，因此`length - 1 = 15`，即二进制的`0000 0000 0000 0000 0000 0000 0000 1111`。`&`是按位与，由于是对15进行按位与，也就相当于取最后四位，结果就是对16的余数。这里使用按位与运算是因为比起除法和求余数，按位与要快得多。*

当红石线开始更新后，游戏会将其本身放入HashSet中，再把六个毗邻放入，顺序依据游戏所指定的**方向的默认顺序**，即：**下、上、北、南、西、东**。分别计算这7个位置的哈希值，就可以得到他们在数组中的存储序号。以(100,64,2000)为例，在这里分别是

| 方向 | 更新源 | 序号 |
| ---- | ------ | ---- |
| 原点 | O      | 9    |
| 下   | -Y     | 8    |
| 上   | +Y     | 14   |
| 北   | -Z     | 14   |
| 南   | +Z     | 8    |
| 西   | -X     | 14   |
| 东   | +X     | 8    |

接着，便是游戏从HashSet中取出这些位置，依次对它们的毗邻产生方块更新。取出的顺序以序号较小为优先，相同序号这以先加入者为优先（因为后加入者被挂在了同一格子的末尾）。以(100,64,2000)为例，更新顺序就是：下、南、东、原点、上、北、西。即-Y、+Z、+X、O、+Y、-Z、-X。

### 特异点

读者可能注意到了，在如上所举的例子中，虽然序号给出了16个格子，但七个坐标却仅放在了序号为8、9、14三个格子中。而这还不是个别现象。97%的情况下，7个坐标仅会被存在3个格子之中。

一个点的哈希值仅由一个点的坐标确定，而一个点毗邻的六个点，坐标不过是在x，y，z三个分量上 $\pm1$罢了。体现在哈希值上，就是哈希值 $\pm1,\pm31,\pm961$罢了。很有可能的是，这7个数值拥有完全相同的高16位！这意味着在进行得出序号的异或操作时，它们很有可能是在和相同的高16位进行异或运算，而我们知道 $x+31(y+31z)\equiv x-(y+31z)\equiv x-y+z(\text{mod}\quad16)$，这就意味着具有相同$x-y+z$值的坐标很有可能就被存储在同一个格子之中！

sharir1701注意到了这一点，其后Earthcomputer在2018年发布了《红石粉更新顺序》（Redstone Dust Update Order），其与WARBEN和KaptainWutax指出，将七个坐标分为具有相同$x-y+z$值的三组是可行的，原点独自成组，-Y、+Z、+X一组，而+Y、-Z、-X一组。组间的顺序难以捉摸，但组内总存在先后顺序，这一顺序是由坐标加入HashSet的顺序决定的。

Earthcomputer还指出，这一规律成立的概率大约是97%，这一数字可以这样估算：如果异或时高16位不同，最有可能是+961和-961除以65536得到的商不同，这意味着在这1922的跨度里横跨了65536的边缘。考虑到哈希值计算的散列性，这一现象发生的概率大致是 $\dfrac{1922}{65536}\approx2.9\%$，那么规律生效的概率大约为 $97\%$ 了。

此外，也容易得出，如果一个点是规律失效点~~特异点~~，那么其南北两格之外就不可能是失效点了，但东西方向可能有几百格甚至上千格都是规律失效点。规律失效点的分布在局部上并不均匀。

下图面朝西方，第四列的红石全部处于特异点。

![](Illustration/方块更新与延迟理论的拓展/方块更新与延迟理论的拓展-e31cf0cf.png)

KaptainWutax随后穷举了哈希值的取值范围，给出了如下的表格（部分）：

| 更新源顺序                | 概率    |
| ------------------------- | ------- |
| -Y, +Z, +X, O, +Y, -Z, -X | 24.267% |
| +Y, -Z, -X, O, -Y, +Z, +X | 24.267% |
| O, -Y, +Z, +X, +Y, -Z, -X | 12.133% |
| O, +Y, -Z, -X, -Y, +Z, +X | 12.133% |
| -Y, +Z, +X, +Y, -Z, -X, O | 12.133% |
| +Y, -Z, -X, -Y, +Z, +X, O | 12.133% |
| 其余每项                  | < 0.2%  |

附加结论是，Y坐标先更新的概率高达72.8%，而X坐标不可能最先更新。

笔者随后穷举了-2048 ~ 2048，0 ~ 256，-2048 ~ 2048范围内的全部方块，结果如下（部分）：

| 更新源顺序                | 概率    |
| ------------------------- | ------- |
| -Y, +Z, +X, O, +Y, -Z, -X | 24.242% |
| +Y, -Z, -X, O, -Y, +Z, +X | 24.243% |
| O, -Y, +Z, +X, +Y, -Z, -X | 12.161% |
| O, +Y, -Z, -X, -Y, +Z, +X | 12.123% |
| -Y, +Z, +X, +Y, -Z, -X, O | 12.161% |
| +Y, -Z, -X, -Y, +Z, +X, O | 12.123% |
| 其余每项                  | < 0.2%  |

### 方块更新和深度优先

下面介绍存在多个红石线时的更新规律。拉下拉杆。

![](Illustration/方块更新与延迟理论的拓展/方块更新与延迟理论的拓展-151f8e8b.png)

拉杆的充能范围是附着，更新范围是本身的毗邻外加附着的毗邻。这其中包含了第一格红石线，那么拉杆的更新会被暂时中断，待到第一格红石完成之后才会继续完成拉杆剩余的更新。同理，如果一个方块的更新波及到了另一个方块的更新，那么原方块的更新进程会中断，待后一个方块更新完成后才会继续完成原方块剩余的更新，而后一个方块又有可能波及到再其他的方块，于是更新就又深了一层。这一个过程被称为深度优先。

所以拉杆可能会在所有红石线更新完成之后才会结束它的更新，但由于其没有什么别的可以更新的方块，因此我们忽略这些无用的更新。

第一格红石线亮起，开始更新，创建7个更新源。这时我们不知道具体的更新源顺序，所以有可能是第三格红石线先受到更新，也有可能是第二格红石线先受到更新。但即使第三格红石线先被更新，其也不能激活，因为第二格红石线尚未亮起，第三格红石线没有信号。所以第一格红石线一定会让第二格红石线亮起，此后第二格红石线又会让第三格亮起，第三格红石线激活活塞，让其进入启动延迟。随后，再完成所有红石线和拉杆无用的更新。

熄灭时的过程要复杂一些，拉杆更新到第一格红石线，第一格红石线意识到自己没有来自拉杆的能量了，但其并不会简单地将信号强度降为0，而只是变为13，因为其认为第二格红石线仍可以给它供给能量！

在经历复杂的更新之后，其会更新到第二格红石线，而第二格红石线又会认为第一格和第三格红石线会给它供给信号，所以也只是减一。所以红石线将会经历从自身强度到0之间的每一个信号强度，带来大量重复无用的更新。

panda4994解释了为何红石线会产生如此多的无用更新，并尝试从修改游戏代码的角度解决这一问题，这里不多赘述。

如下图所示，破坏红石块，TNT会有何反应？

![](assets/方块更新与延迟理论的拓展-39c0666a.png)

破坏红石块发出更新，右侧红石线收到更新，其认为自身仍被左侧红石线供给能量，因此信号只衰减到13。同时，红石线的指向也发生改变，现在它指向TNT。

右侧红石线将发出更新，在这个位置，只有原点更新源会产生有效的更新，原点放出的六个更新遵循“西东下上北南”的顺序，因此如果TNT位于西侧或北侧，则一定会先被更新而点燃。

但如果TNT位于东侧或南侧，此时先被更新的就是左侧红石线了，它的强度会衰减到12。但左侧红石线将面临位置随机性：如果原点更新源先更新，则会先更新到右侧红石线，如果右侧更新源先更新，则会先更新到TNT，使其爆炸。

如果再次更新到右侧红石线，这里将重复第一次的分析，考虑到之前的方向性，其会再次更新左侧红石线，而左侧红石线同样会优先更新右侧红石线。两个红石线互相更新，每次衰减2，直到熄灭。等到TNT被更新时，红石线已经失去了信号，则红石线不会爆炸。

综上所述，当面朝南侧或西侧时，TNT一定爆炸；当面朝北侧或东侧时，TNT有约50%概率会爆炸。

![](assets/方块更新与延迟理论的拓展-d6abf42a.png)

破坏如上图所示的红石块，无论方向性和位置性，TNT一定会爆炸。

在这个位置，能更新到TNT的红石线总共有三个，分别是黄色位置、蓝色位置和绿色位置。黄色位置首先衰减为13，若想TNT不爆炸，则黄色位置必须先更新蓝色位置而不是TNT，蓝色位置衰减到12,。此后，蓝色位置更新黄色位置，可是蓝色位置此时仍会被后面的红石线维持12的信号，所以黄色位置的更新将会完成完整的二阶毗邻的更新，进而更新到TNT。所以若想TNT不爆炸，蓝色位置就不能先更新黄色位置。，它必须继续前进，使前方的红石线强度降低。

绿色位置则是另一个极端，如果它被更新到，则会立即更新到TNT，所以它不能接受更新，必须一直维持在10强度。这意味着无论黄色位置和蓝色位置怎么更新，它们的强度至少为5和6。现在这里产生了矛盾，黄色位置不可能凭空衰减到0，在绿色位置更新前，如果更新到了黄色位置，则它一定会完成一个完整的包含七个更新源的更新，那么TNT一定会爆炸。

![](assets/方块更新与延迟理论的拓展-4af34124.png)

这是一个神奇的电路，当拉下或拉回拉杆时，最后端的投掷器里的一个物品会被投掷器依次投递，然后从最前端的投掷器中投出。动力铁轨激活是先进行NC更新，后进行PP更新，而观察者检测PP更新，这就意味着第一个动力铁轨更新到观察者前，会先用NC更新激活下一个动力铁轨。最终，最后一个铁轨完成NC更新后进行它的PP更新，这才更新到观察者，使得铁轨的激活方向看起来与投掷器的投递方向相反了。

用红石线替代铁轨，则是完全相反的情况了，因为红石线先进行PP更新，后进行NC更新。请读者自行分析激活和撤销激活红石线的情况。

### 线路稳定性

接下来，Earthcomputer尝试根据红石线更新顺序的相关结论，解决空间随机性的问题。

首先解释如下的电路为何会具有空间随机性。这里我们假定面朝北方，其他朝向的分析是类似的，请读者自行完成。

![](Illustration/方块更新与延迟理论的拓展/方块更新与延迟理论的拓展-d6899383.png)

拉杆更新到其附着方块上的红石线（记为中心），其激活，产生七个更新源，但二阶毗邻的位置即使可以更新到红石线也不会激活，因为没有能量。最后只有原位的更新源可以激活西一或者东一红石线，具体的顺序要依据方块更新顺序。

面朝北方，W优先于E，西侧先更新，西一红石线激活，产生七个更新源。这里需要着重注意的是O更新源（位于西一）和+X更新源（位于中心）。如果原位更新源先更新，其会更新到西二红石线，深度优先会使得左侧活塞先伸出；如果东侧更新源先更新，其会更新到东一红石线，深度优先会使得右侧活塞先伸出。那么关键就在于西一红石线的更新源顺序。也就是O和+X的更新顺序。这无法比较，且可以认为有50%概率左侧伸出，50%的概率右侧伸出。

如果希望左侧活塞先伸出，那么就要O先于+X更新。这很难做到，因为二者不在同一个组中。不能期望O优先于+X更新，但-Y优先于+X。将西二红石线降低一格，就可以让-Y更新到它，这样就在97%的程度上解决了这一问题。

![](Illustration/方块更新与延迟理论的拓展/方块更新与延迟理论的拓展-e112b9f0.png)

在之前的论述中，我们证明了，特异点哈希值相差1922及以上的点就不可能是特异点，换句话说特异点南北两格之外不可能是特异点。现在电路就被修改成了如下的状态。

![](Illustration/方块更新与延迟理论的拓展/方块更新与延迟理论的拓展-56ed3f3f.png)

拉杆拉下，红石线激活，向前传递，在第一个分叉处，W优先于E，信号进入第一个可能是特异点的淡蓝色混凝土。如果其不是特异点，-Y优先于+X，深度优先使得红石信号一路向左，激活左侧活塞。但如果其是特异点，就不能保证-Y优先于+X。现在假设+X先更新，那么信号向前，到达第二个分叉，W优先于E，信号进入第二个淡蓝色混凝土，但事实上它不可能是特异点了，因为它们哈希值相差了2882,。在这里，-Y优先于+X，信号还是会优先向左传递，依然是左侧活塞先伸出。这样就100%地解决了这一问题。

如下是另一种通用的解决案。第一个分叉点处，淡蓝色混凝土上的红石线开始更新时，我们期望它向西传递信号，但更新仍然有可能跳到分叉点以北，且-Z和+X的更新源都有可能先更新。为了解决这一问题，有必要同时动用-Y和+Y这两个组内优先级较高的方向，最后的结论也就如下图了。

![](Illustration/方块更新与延迟理论的拓展/方块更新与延迟理论的拓展-649c20a1.png)

如何让右侧活塞先伸出？这就要求+X优先于O先更新，这难度更大。所以我们被迫放弃在左一红石线上解决这一问题，将视线放回中心红石线，尝试让右一红石线先更新，并让右一红石线先更新右侧，这就必须取消左一红石线，同时根据方向使用+Y或者-Y。

![](Illustration/方块更新与延迟理论的拓展/方块更新与延迟理论的拓展-f7407b5b.png)

将左一红石线放到北侧（北一位置），现在E优先于N，淡蓝色混凝土上的红石线先更新。从该位置跳到北一位置可以通过-X更新源和-Z更新源，好在+Y优先于这二者。将东二红石线抬高一格，就在97%程度上解决了这一问题。

如果要100%解决这一问题，还需要增加一条线路，解决案如下。

![](Illustration/方块更新与延迟理论的拓展/方块更新与延迟理论的拓展-4c364271.png)

至此，我们就完成了所有红石线更新的内容。

## NC更新与PP更新

在1.13后，游戏使用NeighborChanged（邻位更新）和PostPlacement（放置后更新）两种更新信号。这两种信号的名称来源于MCP对游戏的反混淆。（MCP是mod coder pack的简称，其是一种反编译Minecraft的工具）

无论MCP给这两种更新信号的命名是否合理，这两种更新信号已经是需要玩家所认识的了，因而我们只将这两种更新信号命名为NC更新与PP更新。读者将会看到，NC更新对应传统方块更新，而PP更新对应方块变化，或者说状态更新（state change）。可以做大致如下的理解：：在1.13时，游戏将方块更新的大部分内容归由NC更新管理，而PP更新主要负责观察者和方块状态及合法性的判断，这才是观察者的检测项变得条理的原因。

在观察者的检测项中，我们曾经介绍过观察者可以检测栅栏的连接方式，这正是PP更新的主要用途——其主要被用于更新方块数据值，也就是方块的状态。这同样解释了为什么我们可以在F3调试界面中判断一些变动是否是方块变化，显然实体方块的充能不是方块变化。

除此之外，各类有附着的方块，在附着方块消失时可能会掉落，掉落的更新一般由PP更新主导的，这就是为什么一个浮空的按钮即使被按下也可以正常发出信号而不致掉落——红石电路的大部分更新传递都只会触发NC更新。总的来说，PP更新负责的是检测方块在放置后是否“正常”，如珊瑚的失水、混凝土粉末的凝固等等。

NC更新家族非常庞大，不如说在没有PP更新的时候NC更新就是全部的方块更新，红石电路也是依赖NC更新传递的。

虽说NC更新和PP更新看似使得方块更新变得条理，但事实上仍有大量迷惑的现象和例外。响应NC更新的，除红石元件外，也还包括流体的状态检测、霜冰融化检测、海绵吸水检测、铁轨附着检测等。相应PP更新的，有各类方块的附着判断、各类连接性方块的连接判断、音符盒乐器类型、中继器锁存、树叶更新和木头的距离、重力方块掉落检测等。这些早就了一些奇怪的现象，如浮空的压力板可以激活浮空的门、中继器可以附着在活板门上，然后再打开活板门等。总之，在这方面具体的情况需要具体分析。

PP更新和NC更新的另一个不同之处在于其具有方向性：在浮空火把的侧面放置方块虽然会让火把收到PP更新，但火把不会掉落，它只会在收到附着方向的PP更新时才会掉落。

PP更新还有和NC更新不一样的顺序：NC更新的顺序是“西东下上北南”，而PP更新的顺序是：“西东北南下上”。

~~这边如《基础红石原理》一样应该加个附表吧。~~

## 更新抑制

2016年6月11日，panda4994介绍了一种阻止方块更新的方法，其核心思想是借助同一游戏刻中的大量方块更新，致使Java的栈内存溢出，使得原本应当进行的方块更新被抑制。

事实上，这本不应发生——如果Java的栈内存溢出，游戏应当抛出异常并自动结束。但panda4994注意到，由玩家产生的更新（如放置方块等）导致的栈溢出并不会结束游戏，游戏会继续运行并忽视其后所应正常进行的方块更新。这是更新抑制的核心原理。

在实际应用中，我们首先需要一种大规模产生方块更新的方式，panda使用的是大量红石线，不过，大量处于BUD态的动力铁轨也是一个不错的选择。



# 第四节 漏斗理论

## 漏斗概述

漏斗是于1.5版本中加入的红石输出元件，其具有5格的存储空间。漏斗的主要功能被称为漏斗的输出特性，简述如下：

- 将其上1×1×1范围内的物品实体吸入自己的存储空间。
- 漏斗可以从上方的容器中抽取物品，如果漏斗上方有容器，漏斗不再尝试吸入物品实体。
- 漏斗可以将存储空间中的物品，传输至自己指向的容器中。漏斗的指向只能是下方或四周，因此只用漏斗是不可能将物品向上传递的。

当漏斗被激活时，称漏斗被“锁”住，此时失去如上的功能。漏斗被激活时可以发生变化，因此是一个输出元件。

能与漏斗进行互动的容器或类容器有包括：

- 箱子和陷阱箱，但不包括末影箱，漏斗能简单地从箱子中取出，或放入物品。
- 发射器、投掷器、末影盒。
- 箱子矿车、漏斗矿车。（尽管它们是实体而非方块）
- 熔炉，在熔炉上方并指向熔炉的漏斗会将物品输入到待烧炼的物品格，在侧面并指向熔炉的漏斗会将物品输入到燃料的物品格，在熔炉下方的漏斗会将物品从成品的物品格中取出，不过，当使用岩浆桶作为燃料时，漏斗也可以将空桶取出。
- 酿造台，漏斗可以向酿造台中输入水瓶、烈焰粉及酿造原料，同时也会将药水取出，不过值得注意的是只要输出栏中有药水，无论酿造是否完成，漏斗都会直接取出。
- 其他漏斗，漏斗也可以将物品输入其他漏斗，或是从其他漏斗中将物品取出，两个漏斗可以同时进行自己的工作，相互独立。

漏斗具有很多功能，而这些功能在实现时需要运算，也就会带来卡顿。激活漏斗可以禁用漏斗的一切功能，此时卡顿最小 ~~（有待考据）~~。如果某些漏斗仅用作物品传输而非吸入物品，或不希望杂物导入物品中，可以在漏斗上放置容器，此时漏斗不再尝试吸入物品。但多放置的容器也会带来一定的卡顿，因为此时不仅漏斗要尝试从容器中取出物品，熔炉等方块还会尝试是否开始燃烧，选择合适的容器是有必要的。漏斗上的容器物品格数越少，漏斗取出物品时检测越少，卡顿也就越小，因此投掷器优于小箱子，后者又优于大箱子。熔炉、炼药台等容器物品栏较为特殊，需要特殊处理，最终效果与投掷器类似。堆肥桶没有物品栏，漏斗直接检测堆肥桶的方块数据值，带来的卡顿是极小的，这也是目前最合适的放置在漏斗上用于减小卡顿的类容器。

漏斗的延迟是8gt，这是一个值得记忆的数据，这一延迟限制了物品在漏斗内的传输速率，换算成常用单位，也就是2.5物品每秒，或150物品每分钟，或9000物品每小时。

漏斗是一个方块实体，统一在Tile Entity事件更新，同一游戏刻内的更新顺序取决于加载顺序，如玩家先放置的漏斗总先更新。必须注意的是区块重载会破坏已有的加载顺序，重载的顺序具有随机性。

## 即时更新理论对漏斗的修正

Sancarn和Selulance尝试将漏斗纳入即时更新理论的范畴。

必须研究漏斗对于不同同步性的下降沿信号，将物品开始漏下需要多久的延迟。

![](Illustration/方块更新与延迟理论的拓展/方块更新与延迟理论的拓展-36edd094.png)

事实证明，对大部分信号，漏斗是一个同步元件，延迟为1pt。这意味着漏斗和活塞类似，有着1pt的固定延迟。

接下来，必须研究比较器从漏斗中读取有信号时，漏斗作为输入元件的同步性。

![](Illustration/方块更新与延迟理论的拓展/方块更新与延迟理论的拓展-7c0a0eb0.png)

事实证明，漏斗也是一个同步性输入元件，其会减少比较器的1pt延迟。

然而漏斗并非是严格意义上的同步元件。换句话说，同步信号会减少非同步元件的1pt延迟，但不会对同步信号产生影响，漏斗却会被优先的几种同步信号减少1pt延迟，且这些同步信号总与实体有关，如掉落沙。

![](Illustration/方块更新与延迟理论的拓展/方块更新与延迟理论的拓展-c7777872.png)

可以预料到，掉落沙这种同步性输入方式会使得漏斗的延迟减少1pt，从而是无延迟的。这意味着上下两路都仅花费1pt，活塞同时收回。

Sancarn和Selulance所做的诸多实验都指向一个事实，漏斗既非如中继器、比较器一类的非同步元件，又非如活塞一类的同步元件。漏斗更新的位置介于Block Event和下一游戏刻的Next Tick Entry之间，而掉落沙实验证明，漏斗更新的位置位于Entity Update之后。这与我们在《基础红石原理》中认识到的更新顺序一致。

漏斗在Tile Entity事件工作，当漏斗被撤销激活时，会立即在下一个Tile Entity事件漏下一个物品，不过在时间轴顺序中，Tile Entity事件离活塞刻节点非常接近，因此大部分激活方式在更新到漏斗前都要先经过一个活塞刻节点，因此大部分激活方式都会使漏斗产生1pt的延迟。不过仍然有一小部分时间介乎于活塞刻节点与Tile Entity事件，Entity Update事件就是这样的。Entity Update事件提供信号下降沿时，按照更新顺序，漏斗会在下一个Tile Entity事件漏下物品，而没有跨过活塞刻节点，这就出现了我们上述实验中漏斗延迟消失的现象。

这是一个具有启示意义的结论，因为我们知道玩家的活动是在Network Update事件进行更新，而其他实体的更新是在Entity Update事件，因此，利用漏斗，便可以做到检测一个实体是否是玩家。

同样的事情也发生在上升沿，也就是说，只要漏斗被撤销激活，总会在下一个Tile Entity事件处理第一个物品，无论是取出、漏下、吸入物品。因此对于大部分输入方式，漏斗具有同步性，延迟为1pt，对少部分事件，漏斗没有延迟。而使用比较器检测漏斗时，无论是检测上升沿、下降沿，或是检测漏斗本身、上方的容器、指向的容器，信号都是同步的，比较器延迟恒为1pt，并输出一个在Next Tick Entry事件的非同步信号。

以上结论只适合于漏斗处理第一个物品，当漏斗持续地工作时，延迟为8gt。

## 漏斗理论

事实是，漏斗和中继器等NTE元件有着类似的工作方式，漏斗有着8的冷却值倒计时，这和中继器有着2、4、6、8的冷却值倒计时类似。每游戏刻的Tile Entity事件，漏斗的冷却值倒计时都减少1，接着漏斗都要检查自己的冷却值倒计时，为0时尝试处理物品，并在处理成功时将冷却值倒计时重设为8，否则没有任何响应。中继器只会在激活与撤销激活时使用它的冷却值倒计时，而漏斗无时不刻运行着它的倒计时。

当漏斗的冷却值倒计时为0，但漏斗没有物品可供处理时，漏斗不会将冷却值倒计时设为8而是保持在0，这意味着漏斗会在之后的每一个Tile Entity事件尝试处理物品，包括漏下、取出或吸入物品。

很明显，这个新的理论是兼容漏斗被撤销激活时的行为的，因为漏斗冷却值倒计时为0时，自然是在下一个Tile Entity事件立即尝试处理物品。

[>_<]:
漏斗还有一个奇怪的特性：当漏斗的冷却值倒计时小于等于1时，以非玩家方式放入物品时，漏斗的冷却值倒计时会被重置为8。这一特性已被实验证实。

通过漏斗理论，我们可以解释如下的现象：漏斗内物品的流动情况与两个漏斗的放置顺序有着一定区别。现在在上方漏斗放入一定量的物品。

![](Illustration/方块更新与延迟理论的拓展/方块更新与延迟理论的拓展-c71e1370.png)

当下方漏斗先被放置时，其首先更新。下方漏斗内没有物品，其取出上方漏斗的一个物品。紧随其后，上方漏斗将物品送入下方漏斗。整体效果就是每8游戏刻上方漏斗减少2个物品。

当上方漏斗先被放置时，其首先更新，将物品送入下方漏斗，而下方漏斗会因此将冷却倒计时重置为8，在这一游戏刻中，冷却倒计时被减少为7。7gt后，下方漏斗将其中的物品放入箱子，再将一个物品从上方取出。8gt时，上方漏斗再将一个物品放入下方漏斗之中。因此物品虽然也是两个两个向下流的，但这两个物品间存在1gt的时间差。这就是说，如果漏斗将物品送入一个空漏斗，该空漏斗将物品送出需要7gt。

《基础红石原理》对漏斗时钟有了初步的介绍，下面有必要详细计算漏斗时钟的周期。

如下是一个尚未放入物品的漏斗时钟。

![](Illustration/方块更新与延迟理论的拓展/方块更新与延迟理论的拓展-cbb27eda.png)

现在假设漏斗时钟中有一个物品在流动。当漏斗将左侧物品送入右侧，7游戏刻时右侧漏斗将物品漏回左侧。同理，14游戏刻时物品再次送往右侧，周期为14gt。

现在假设漏斗时钟中有两个物品在流动，左侧和右侧漏斗各有一个物品，红石块锁住右侧漏斗，现在左侧漏斗将物品送入右侧漏斗，左侧漏斗内空。2gt后，比较器熄灭，活塞开始推出，红石块位置移动，右侧漏斗会在这一游戏刻将物品送回左侧漏斗，第二个物品则需要8gt。同理，恢复原位需要同样的10gt，总延迟为20gt。

当漏斗内物品多于2个时，计算就和两个相同了。除了移走红石块同时流入的物品，其他物品都需要8gt来传输，比较器则需要2gt，当漏斗内共有n（n>1）个物品时，漏斗时钟的周期为16n-12 gt。以此计算，单个漏斗时钟所能达到的周期最长是255.4秒。

除了漏斗时钟外，另外一种常用的时钟是漏斗链时钟。

![](Illustration/方块更新与延迟理论的拓展/方块更新与延迟理论的拓展-3af5cef5.png)

漏斗链时钟最大的特点在于无论不会因输入控制而产生混乱，因为拉杆仅控制一个漏斗的激活状态。拉杆拉回时，物品在漏斗链中循环，拉杆拉下时，物品会在若干游戏刻后被锁在开关控制的漏斗中。而下面的中继器时钟虽然拥有相同的周期和相近的占空比，但想做到这一点就比较困难了。

![](Illustration/方块更新与延迟理论的拓展/方块更新与延迟理论的拓展-2d1b5bbc.png)

漏斗链时钟中，大多数漏斗都是空着的，这意味着漏斗可以在接收到物品的同一游戏刻进行一次更新，随后7游戏刻将物品送入下一漏斗。对n的漏斗的漏斗链时钟，周期为7n gt。

漏斗移位器的原理与漏斗链时钟类似，向被锁住的漏斗链中输入短负脉冲，这一信号仅允许物品移动一个漏斗，从而达到移位的功能。

![](Illustration/方块更新与延迟理论的拓展/方块更新与延迟理论的拓展-002411ca.png)

# 第五节 0t脉冲

## 0t脉冲的细化

《基础红石原理》介绍了若干短脉冲，主要侧重于短脉冲作用于粘性活塞的若干情形，下面对0t脉冲进行细化。

在一个标准游戏刻中，选取不同的事件充当上升沿和下降沿，就可以获得不同类型的短脉冲。除去Network Update事件，分别以其余五个事件作为上升沿和下降沿，便可以得到25种0t脉冲。这里的0t脉冲是相较于标准游戏刻长度而言的，有些0t脉冲甚至跨过了游戏刻节点，也可以被称为1gt脉冲；而有些0t脉冲由于无法使活塞响应，也可以被称为短0t脉冲。0t脉冲就是这样的一个种类丰富的大家族。

不同元件对不同0t脉冲会有不同的反应，在《基础红石原理》中我们就已经认识到，中继器总会响应0t脉冲，无论它有多短；而比较器和红石火把则会在点亮前先检测是否仍有信号，否则不会亮起；活塞顺推的延迟取决于经过的Block Event事件个数。举例来说，NTE-TE的0t脉冲使得粘性活塞在本游戏刻的Block Event事件开始伸出，下一游戏刻的Block Event事件伸出完成，也就是1pt顺推；NTE-BE的0t脉冲使得粘性活塞在本游戏刻的Block Event事件开始推出并推出完成，也就是0t顺推；而NTE-NTE的0t脉冲不经过Block Event事件，活塞不会响应。

红石线、动力铁轨、活板门、栅栏门等方块都是即时响应的，同时游戏总会播放栅栏门等开关的音效，但游戏会渲染其是否亮起或是否打开则是在Block Event事件之前，换句话说如果希望红石线闪烁或栅栏门打开，所使用的的0t脉冲就必须经过Block Event事件之前，如NTE-BE脉冲或NTE-TE脉冲，而BE-BE脉冲就不能让红石线闪烁。这一点至少对于1.12-1.13是成立的。~~（在1.15中似乎在NTE前更新，有待考据）~~

*例 分析如下的短脉冲发生器，按下按钮，判断中继器和粘性活塞的响应情况。*

![](Illustration/方块更新与延迟理论的拓展/方块更新与延迟理论的拓展-406d1ed2.png)

*很明显，这是一个NTE-BE脉冲，中继器响应，粘性活塞0t顺推。*

*例 分析如下的短脉冲发生器，拉回拉杆，判断中继器和粘性活塞的响应情况。*

![](Illustration/方块更新与延迟理论的拓展/方块更新与延迟理论的拓展-e320c52d.png)

*很明显，这是一个TE-NTE脉冲，中继器响应，粘性活塞无响应。*

Defanive中继器也可以用于制作短脉冲发生器，拉下拉杆，Defanive中继器给出NTE-BE短脉冲，随后信号常亮。如果只需要NTE-BE短脉冲，可以考虑输入一个短脉冲。

![](Illustration/方块更新与延迟理论的拓展/方块更新与延迟理论的拓展-f1c22351.png)

pi314159265358978串联了多个Defanive中继器，并说明这种NTE-BE短脉冲可以通过如下的装置。

![](Illustration/方块更新与延迟理论的拓展/方块更新与延迟理论的拓展-47a04b76.png)

## 活塞更新深度

由于红石线更新具有随机性，如下的装置无法准确判断拉杆拉下后的情况。

![](Illustration/方块更新与延迟理论的拓展/方块更新与延迟理论的拓展-b0a72c33.png)

但如下的装置却并非如此，两个面对面的活塞处于BUD态，谁可以伸出取决于谁先受到更新。在拉杆拉下时，其后的四个普通活塞激活，可以确定这四个活塞从左向右更新，因此左侧活塞一定可以伸出而右侧无法伸出。

![](Illustration/方块更新与延迟理论的拓展/方块更新与延迟理论的拓展-752f76cf.png)

和NTE元件类似地，每游戏刻中的Block Event事件，所有需要更新的活塞也会被加入一个列表，但这个列表的更新顺序并不仅仅取决于活塞加入列表的顺序，还取决于活塞更新的深度。活塞更新的深度指的是从信号源到活塞间需要几个活塞作为更新，如上图后侧的四个普通活塞，深度分别为0,1,2,3。从同一0深度活塞开始更新的更高深度的活塞，深度小的一定优先于深度大的更新。这一过程被称为广度优先。

那么读者不难理解如下的装置，左侧在下降沿是一个BE-BE脉冲发生器，其下6个活塞深度从右至左分别为0,1,2,3,4,5。

![](Illustration/方块更新与延迟理论的拓展/方块更新与延迟理论的拓展-f3559190.png)

BE-BE脉冲于0深度活塞开始收回后产生，5深度活塞开始收回后结束。0深度活塞不仅会更新到1深度活塞，其还会更新到右侧的脉冲深度检测器，深度检测器中最左侧的活塞也会是1深度的，而受其影响，深度检测器中的活塞从左到右分别为1,2,3...且脉冲发生器中的各活塞优先于同深度的深度检测器中的活塞更新。因此右侧仅有深度为1-4的活塞会响应。

![](Illustration/方块更新与延迟理论的拓展/方块更新与延迟理论的拓展-94305299.png)

因此，如果希望激活下图右侧的两个活塞，左侧的短脉冲发生器需要使用4个活塞。

![](Illustration/方块更新与延迟理论的拓展/方块更新与延迟理论的拓展-669d9885.png)

并非所有BE-BE短脉冲发生器都能得到合理的深度，举例来说，如下的BE-BE短脉冲发生器就是如此。上升沿到来后，两个普通活塞深度分别为0和1，这就意味着被该短脉冲直接激活的活塞深度也为0，但一条红石线上的红石线更新顺序具有随机性，不能判断该活塞是否优先于复位的两个普通活塞先更新。

![](Illustration/方块更新与延迟理论的拓展/方块更新与延迟理论的拓展-c8bff7aa.png)

在上升沿和下降沿之间串联若干无延迟中继器便可以解决这一问题了。

![](Illustration/方块更新与延迟理论的拓展/方块更新与延迟理论的拓展-33de880b.png)

## 超频时钟

既然存在0t脉冲，那么就一定存在20Hz的时钟，这样的时钟被称为超频时钟。超频时钟是游戏中可以获得的周期最短的时钟，一般而言只有命令方块可以在这种时钟下如期工作，中继器、栅栏门等方块可以响应这种时钟信号。

有各式各样的0t脉冲，就会有各式各样的超频时钟，而从0t脉冲发生器到超频时钟，只需要将若干短脉冲发生器错位并联而得到不同的相位，使用常规时钟驱动，保证每gt产生一次短脉冲即可。

这是一个BE-BE超频，观察者时钟周期为4gt，故需要4个BE-BE短脉冲发生器来生成超频信号，两个观察者时钟错开1gt，时钟信号又由中继器错开2gt，就得到了BE-BE超频。

![](Illustration/方块更新与延迟理论的拓展/方块更新与延迟理论的拓展-b630f9e5.png)

如下是NTE-BE超频，由于比较器不能响应过短的脉冲，这里用2挡中继器激活它们，也就用到了更多的NTE-BE短脉冲发生器。

![](Illustration/方块更新与延迟理论的拓展/方块更新与延迟理论的拓展-d218f51b.png)

如下的BE-TE超频使用了压线的思路，每个粘液块时钟每6gt会给出一个TE-BE的短负脉冲，树叶电路使得6个粘液块时钟分别相差1gt，最后按正脉冲来记，得到的就是BE-TE超频。

![](Illustration/方块更新与延迟理论的拓展/方块更新与延迟理论的拓展-03284ef1.png)
